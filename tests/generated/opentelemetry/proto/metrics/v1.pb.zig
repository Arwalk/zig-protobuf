// Code generated by protoc-gen-zig
///! package opentelemetry.proto.metrics.v1
const std = @import("std");
const Allocator = std.mem.Allocator;
const ArrayList = std.ArrayList;

const protobuf = @import("protobuf");
const ManagedString = protobuf.ManagedString;
const fd = protobuf.fd;
const ManagedStruct = protobuf.ManagedStruct;
const json = protobuf.json;
const UnionDecodingError = protobuf.UnionDecodingError;
/// import package opentelemetry.proto.common.v1
const opentelemetry_proto_common_v1 = @import("../common/v1.pb.zig");
/// import package opentelemetry.proto.resource.v1
const opentelemetry_proto_resource_v1 = @import("../resource/v1.pb.zig");

// AggregationTemporality defines how a metric aggregator reports aggregated
// values. It describes how those values relate to the time interval over
// which they are aggregated.
pub const AggregationTemporality = enum(i32) {
    // UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
    AGGREGATION_TEMPORALITY_UNSPECIFIED = 0,
    // DELTA is an AggregationTemporality for a metric aggregator which reports
    // changes since last report time. Successive metrics contain aggregation of
    // values from continuous and non-overlapping intervals.
    //
    // The values for a DELTA metric are based only on the time interval
    // associated with one measurement cycle. There is no dependency on
    // previous measurements like is the case for CUMULATIVE metrics.
    //
    // For example, consider a system measuring the number of requests that
    // it receives and reports the sum of these requests every second as a
    // DELTA metric:
    //
    //   1. The system starts receiving at time=t_0.
    //   2. A request is received, the system measures 1 request.
    //   3. A request is received, the system measures 1 request.
    //   4. A request is received, the system measures 1 request.
    //   5. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_0 to
    //      t_0+1 with a value of 3.
    //   6. A request is received, the system measures 1 request.
    //   7. A request is received, the system measures 1 request.
    //   8. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_0+1 to
    //      t_0+2 with a value of 2.
    AGGREGATION_TEMPORALITY_DELTA = 1,
    // CUMULATIVE is an AggregationTemporality for a metric aggregator which
    // reports changes since a fixed start time. This means that current values
    // of a CUMULATIVE metric depend on all previous measurements since the
    // start time. Because of this, the sender is required to retain this state
    // in some form. If this state is lost or invalidated, the CUMULATIVE metric
    // values MUST be reset and a new fixed start time following the last
    // reported measurement time sent MUST be used.
    //
    // For example, consider a system measuring the number of requests that
    // it receives and reports the sum of these requests every second as a
    // CUMULATIVE metric:
    //
    //   1. The system starts receiving at time=t_0.
    //   2. A request is received, the system measures 1 request.
    //   3. A request is received, the system measures 1 request.
    //   4. A request is received, the system measures 1 request.
    //   5. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_0 to
    //      t_0+1 with a value of 3.
    //   6. A request is received, the system measures 1 request.
    //   7. A request is received, the system measures 1 request.
    //   8. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_0 to
    //      t_0+2 with a value of 5.
    //   9. The system experiences a fault and loses state.
    //   10. The system recovers and resumes receiving at time=t_1.
    //   11. A request is received, the system measures 1 request.
    //   12. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_1 to
    //      t_0+1 with a value of 1.
    //
    // Note: Even though, when reporting changes since last report time, using
    // CUMULATIVE is valid, it is not recommended. This may cause problems for
    // systems that do not use start_time to determine when the aggregation
    // value was reset (e.g. Prometheus).
    AGGREGATION_TEMPORALITY_CUMULATIVE = 2,
    _,
};

// DataPointFlags is defined as a protobuf 'uint32' type and is to be used as a
// bit-field representing 32 distinct boolean flags.  Each flag defined in this
// enum is a bit-mask.  To test the presence of a single flag in the flags of
// a data point, for example, use an expression like:
//
//   (point.flags & DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK) == DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK
pub const DataPointFlags = enum(i32) {
    // The zero value for the enum. Should not be used for comparisons.
    // Instead use bitwise "and" with the appropriate mask as shown above.
    DATA_POINT_FLAGS_DO_NOT_USE = 0,
    // This DataPoint is valid but has no recorded value.  This value
    // SHOULD be used to reflect explicitly missing data in a series, as
    // for an equivalent to the Prometheus "staleness marker".
    DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK = 1,
    _,
};

// MetricsData represents the metrics data that can be stored in a persistent
// storage, OR can be embedded by other protocols that transfer OTLP metrics
// data but do not implement the OTLP protocol.
//
// MetricsData
// └─── ResourceMetrics
//   ├── Resource
//   ├── SchemaURL
//   └── ScopeMetrics
//      ├── Scope
//      ├── SchemaURL
//      └── Metric
//         ├── Name
//         ├── Description
//         ├── Unit
//         └── data
//            ├── Gauge
//            ├── Sum
//            ├── Histogram
//            ├── ExponentialHistogram
//            └── Summary
//
// The main difference between this message and collector protocol is that
// in this message there will not be any "control" or "metadata" specific to
// OTLP protocol.
//
// When new fields are added into this message, the OTLP request MUST be updated
// as well.
pub const MetricsData = struct {
    resource_metrics: ArrayList(ResourceMetrics),

    pub const _desc_table = .{
        .resource_metrics = fd(1, .{ .List = .{ .SubMessage = {} } }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// A collection of ScopeMetrics from a Resource.
pub const ResourceMetrics = struct {
    resource: ?opentelemetry_proto_resource_v1.Resource = null,
    scope_metrics: ArrayList(ScopeMetrics),
    schema_url: ManagedString = .Empty,

    pub const _desc_table = .{
        .resource = fd(1, .{ .SubMessage = {} }),
        .scope_metrics = fd(2, .{ .List = .{ .SubMessage = {} } }),
        .schema_url = fd(3, .String),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// A collection of Metrics produced by an Scope.
pub const ScopeMetrics = struct {
    scope: ?opentelemetry_proto_common_v1.InstrumentationScope = null,
    metrics: ArrayList(Metric),
    schema_url: ManagedString = .Empty,

    pub const _desc_table = .{
        .scope = fd(1, .{ .SubMessage = {} }),
        .metrics = fd(2, .{ .List = .{ .SubMessage = {} } }),
        .schema_url = fd(3, .String),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Defines a Metric which has one or more timeseries.  The following is a
// brief summary of the Metric data model.  For more details, see:
//
//   https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/data-model.md
//
// The data model and relation between entities is shown in the
// diagram below. Here, "DataPoint" is the term used to refer to any
// one of the specific data point value types, and "points" is the term used
// to refer to any one of the lists of points contained in the Metric.
//
// - Metric is composed of a metadata and data.
// - Metadata part contains a name, description, unit.
// - Data is one of the possible types (Sum, Gauge, Histogram, Summary).
// - DataPoint contains timestamps, attributes, and one of the possible value type
//   fields.
//
//    Metric
//  +------------+
//  |name        |
//  |description |
//  |unit        |     +------------------------------------+
//  |data        |---> |Gauge, Sum, Histogram, Summary, ... |
//  +------------+     +------------------------------------+
//
//    Data [One of Gauge, Sum, Histogram, Summary, ...]
//  +-----------+
//  |...        |  // Metadata about the Data.
//  |points     |--+
//  +-----------+  |
//                 |      +---------------------------+
//                 |      |DataPoint 1                |
//                 v      |+------+------+   +------+ |
//              +-----+   ||label |label |...|label | |
//              |  1  |-->||value1|value2|...|valueN| |
//              +-----+   |+------+------+   +------+ |
//              |  .  |   |+-----+                    |
//              |  .  |   ||value|                    |
//              |  .  |   |+-----+                    |
//              |  .  |   +---------------------------+
//              |  .  |                   .
//              |  .  |                   .
//              |  .  |                   .
//              |  .  |   +---------------------------+
//              |  .  |   |DataPoint M                |
//              +-----+   |+------+------+   +------+ |
//              |  M  |-->||label |label |...|label | |
//              +-----+   ||value1|value2|...|valueN| |
//                        |+------+------+   +------+ |
//                        |+-----+                    |
//                        ||value|                    |
//                        |+-----+                    |
//                        +---------------------------+
//
// Each distinct type of DataPoint represents the output of a specific
// aggregation function, the result of applying the DataPoint's
// associated function of to one or more measurements.
//
// All DataPoint types have three common fields:
// - Attributes includes key-value pairs associated with the data point
// - TimeUnixNano is required, set to the end time of the aggregation
// - StartTimeUnixNano is optional, but strongly encouraged for DataPoints
//   having an AggregationTemporality field, as discussed below.
//
// Both TimeUnixNano and StartTimeUnixNano values are expressed as
// UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
//
// # TimeUnixNano
//
// This field is required, having consistent interpretation across
// DataPoint types.  TimeUnixNano is the moment corresponding to when
// the data point's aggregate value was captured.
//
// Data points with the 0 value for TimeUnixNano SHOULD be rejected
// by consumers.
//
// # StartTimeUnixNano
//
// StartTimeUnixNano in general allows detecting when a sequence of
// observations is unbroken.  This field indicates to consumers the
// start time for points with cumulative and delta
// AggregationTemporality, and it should be included whenever possible
// to support correct rate calculation.  Although it may be omitted
// when the start time is truly unknown, setting StartTimeUnixNano is
// strongly encouraged.
pub const Metric = struct {
    name: ManagedString = .Empty,
    description: ManagedString = .Empty,
    unit: ManagedString = .Empty,
    metadata: ArrayList(opentelemetry_proto_common_v1.KeyValue),
    data: ?data_union,

    pub const _data_case = enum {
        gauge,
        sum,
        histogram,
        exponential_histogram,
        summary,
    };
    pub const data_union = union(_data_case) {
        gauge: Gauge,
        sum: Sum,
        histogram: Histogram,
        exponential_histogram: ExponentialHistogram,
        summary: Summary,
        pub const _union_desc = .{
            .gauge = fd(5, .{ .SubMessage = {} }),
            .sum = fd(7, .{ .SubMessage = {} }),
            .histogram = fd(9, .{ .SubMessage = {} }),
            .exponential_histogram = fd(10, .{ .SubMessage = {} }),
            .summary = fd(11, .{ .SubMessage = {} }),
        };
    };

    pub const _desc_table = .{
        .name = fd(1, .String),
        .description = fd(2, .String),
        .unit = fd(3, .String),
        .metadata = fd(12, .{ .List = .{ .SubMessage = {} } }),
        .data = fd(null, .{ .OneOf = data_union }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Gauge represents the type of a scalar metric that always exports the
// "current value" for every data point. It should be used for an "unknown"
// aggregation.
//
// A Gauge does not support different aggregation temporalities. Given the
// aggregation is unknown, points cannot be combined using the same
// aggregation, regardless of aggregation temporalities. Therefore,
// AggregationTemporality is not included. Consequently, this also means
// "StartTimeUnixNano" is ignored for all data points.
pub const Gauge = struct {
    data_points: ArrayList(NumberDataPoint),

    pub const _desc_table = .{
        .data_points = fd(1, .{ .List = .{ .SubMessage = {} } }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Sum represents the type of a scalar metric that is calculated as a sum of all
// reported measurements over a time interval.
pub const Sum = struct {
    data_points: ArrayList(NumberDataPoint),
    aggregation_temporality: AggregationTemporality = @enumFromInt(0),
    is_monotonic: bool = false,

    pub const _desc_table = .{
        .data_points = fd(1, .{ .List = .{ .SubMessage = {} } }),
        .aggregation_temporality = fd(2, .{ .Varint = .Simple }),
        .is_monotonic = fd(3, .{ .Varint = .Simple }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Histogram represents the type of a metric that is calculated by aggregating
// as a Histogram of all reported measurements over a time interval.
pub const Histogram = struct {
    data_points: ArrayList(HistogramDataPoint),
    aggregation_temporality: AggregationTemporality = @enumFromInt(0),

    pub const _desc_table = .{
        .data_points = fd(1, .{ .List = .{ .SubMessage = {} } }),
        .aggregation_temporality = fd(2, .{ .Varint = .Simple }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// ExponentialHistogram represents the type of a metric that is calculated by aggregating
// as a ExponentialHistogram of all reported double measurements over a time interval.
pub const ExponentialHistogram = struct {
    data_points: ArrayList(ExponentialHistogramDataPoint),
    aggregation_temporality: AggregationTemporality = @enumFromInt(0),

    pub const _desc_table = .{
        .data_points = fd(1, .{ .List = .{ .SubMessage = {} } }),
        .aggregation_temporality = fd(2, .{ .Varint = .Simple }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Summary metric data are used to convey quantile summaries,
// a Prometheus (see: https://prometheus.io/docs/concepts/metric_types/#summary)
// and OpenMetrics (see: https://github.com/OpenObservability/OpenMetrics/blob/4dbf6075567ab43296eed941037c12951faafb92/protos/prometheus.proto#L45)
// data type. These data points cannot always be merged in a meaningful way.
// While they can be useful in some applications, histogram data points are
// recommended for new applications.
pub const Summary = struct {
    data_points: ArrayList(SummaryDataPoint),

    pub const _desc_table = .{
        .data_points = fd(1, .{ .List = .{ .SubMessage = {} } }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// NumberDataPoint is a single data point in a timeseries that describes the
// time-varying scalar value of a metric.
pub const NumberDataPoint = struct {
    attributes: ArrayList(opentelemetry_proto_common_v1.KeyValue),
    start_time_unix_nano: u64 = 0,
    time_unix_nano: u64 = 0,
    exemplars: ArrayList(Exemplar),
    flags: u32 = 0,
    value: ?value_union,

    pub const _value_case = enum {
        as_double,
        as_int,
    };
    pub const value_union = union(_value_case) {
        as_double: f64,
        as_int: i64,
        pub const _union_desc = .{
            .as_double = fd(4, .{ .FixedInt = .I64 }),
            .as_int = fd(6, .{ .FixedInt = .I64 }),
        };
    };

    pub const _desc_table = .{
        .attributes = fd(7, .{ .List = .{ .SubMessage = {} } }),
        .start_time_unix_nano = fd(2, .{ .FixedInt = .I64 }),
        .time_unix_nano = fd(3, .{ .FixedInt = .I64 }),
        .exemplars = fd(5, .{ .List = .{ .SubMessage = {} } }),
        .flags = fd(8, .{ .Varint = .Simple }),
        .value = fd(null, .{ .OneOf = value_union }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// HistogramDataPoint is a single data point in a timeseries that describes the
// time-varying values of a Histogram. A Histogram contains summary statistics
// for a population of values, it may optionally contain the distribution of
// those values across a set of buckets.
//
// If the histogram contains the distribution of values, then both
// "explicit_bounds" and "bucket counts" fields must be defined.
// If the histogram does not contain the distribution of values, then both
// "explicit_bounds" and "bucket_counts" must be omitted and only "count" and
// "sum" are known.
pub const HistogramDataPoint = struct {
    attributes: ArrayList(opentelemetry_proto_common_v1.KeyValue),
    start_time_unix_nano: u64 = 0,
    time_unix_nano: u64 = 0,
    count: u64 = 0,
    sum: ?f64 = null,
    bucket_counts: ArrayList(u64),
    explicit_bounds: ArrayList(f64),
    exemplars: ArrayList(Exemplar),
    flags: u32 = 0,
    min: ?f64 = null,
    max: ?f64 = null,

    pub const _desc_table = .{
        .attributes = fd(9, .{ .List = .{ .SubMessage = {} } }),
        .start_time_unix_nano = fd(2, .{ .FixedInt = .I64 }),
        .time_unix_nano = fd(3, .{ .FixedInt = .I64 }),
        .count = fd(4, .{ .FixedInt = .I64 }),
        .sum = fd(5, .{ .FixedInt = .I64 }),
        .bucket_counts = fd(6, .{ .PackedList = .{ .FixedInt = .I64 } }),
        .explicit_bounds = fd(7, .{ .PackedList = .{ .FixedInt = .I64 } }),
        .exemplars = fd(8, .{ .List = .{ .SubMessage = {} } }),
        .flags = fd(10, .{ .Varint = .Simple }),
        .min = fd(11, .{ .FixedInt = .I64 }),
        .max = fd(12, .{ .FixedInt = .I64 }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// ExponentialHistogramDataPoint is a single data point in a timeseries that describes the
// time-varying values of a ExponentialHistogram of double values. A ExponentialHistogram contains
// summary statistics for a population of values, it may optionally contain the
// distribution of those values across a set of buckets.
pub const ExponentialHistogramDataPoint = struct {
    attributes: ArrayList(opentelemetry_proto_common_v1.KeyValue),
    start_time_unix_nano: u64 = 0,
    time_unix_nano: u64 = 0,
    count: u64 = 0,
    sum: ?f64 = null,
    scale: i32 = 0,
    zero_count: u64 = 0,
    positive: ?ExponentialHistogramDataPoint.Buckets = null,
    negative: ?ExponentialHistogramDataPoint.Buckets = null,
    flags: u32 = 0,
    exemplars: ArrayList(Exemplar),
    min: ?f64 = null,
    max: ?f64 = null,
    zero_threshold: f64 = 0,

    pub const _desc_table = .{
        .attributes = fd(1, .{ .List = .{ .SubMessage = {} } }),
        .start_time_unix_nano = fd(2, .{ .FixedInt = .I64 }),
        .time_unix_nano = fd(3, .{ .FixedInt = .I64 }),
        .count = fd(4, .{ .FixedInt = .I64 }),
        .sum = fd(5, .{ .FixedInt = .I64 }),
        .scale = fd(6, .{ .Varint = .ZigZagOptimized }),
        .zero_count = fd(7, .{ .FixedInt = .I64 }),
        .positive = fd(8, .{ .SubMessage = {} }),
        .negative = fd(9, .{ .SubMessage = {} }),
        .flags = fd(10, .{ .Varint = .Simple }),
        .exemplars = fd(11, .{ .List = .{ .SubMessage = {} } }),
        .min = fd(12, .{ .FixedInt = .I64 }),
        .max = fd(13, .{ .FixedInt = .I64 }),
        .zero_threshold = fd(14, .{ .FixedInt = .I64 }),
    };

    // Buckets are a set of bucket counts, encoded in a contiguous array
    // of counts.
    pub const Buckets = struct {
        offset: i32 = 0,
        bucket_counts: ArrayList(u64),

        pub const _desc_table = .{
            .offset = fd(1, .{ .Varint = .ZigZagOptimized }),
            .bucket_counts = fd(2, .{ .PackedList = .{ .Varint = .Simple } }),
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// SummaryDataPoint is a single data point in a timeseries that describes the
// time-varying values of a Summary metric.
pub const SummaryDataPoint = struct {
    attributes: ArrayList(opentelemetry_proto_common_v1.KeyValue),
    start_time_unix_nano: u64 = 0,
    time_unix_nano: u64 = 0,
    count: u64 = 0,
    sum: f64 = 0,
    quantile_values: ArrayList(SummaryDataPoint.ValueAtQuantile),
    flags: u32 = 0,

    pub const _desc_table = .{
        .attributes = fd(7, .{ .List = .{ .SubMessage = {} } }),
        .start_time_unix_nano = fd(2, .{ .FixedInt = .I64 }),
        .time_unix_nano = fd(3, .{ .FixedInt = .I64 }),
        .count = fd(4, .{ .FixedInt = .I64 }),
        .sum = fd(5, .{ .FixedInt = .I64 }),
        .quantile_values = fd(6, .{ .List = .{ .SubMessage = {} } }),
        .flags = fd(8, .{ .Varint = .Simple }),
    };

    // Represents the value at a given quantile of a distribution.
    //
    // To record Min and Max values following conventions are used:
    // - The 1.0 quantile is equivalent to the maximum value observed.
    // - The 0.0 quantile is equivalent to the minimum value observed.
    //
    // See the following issue for more context:
    // https://github.com/open-telemetry/opentelemetry-proto/issues/125
    pub const ValueAtQuantile = struct {
        quantile: f64 = 0,
        value: f64 = 0,

        pub const _desc_table = .{
            .quantile = fd(1, .{ .FixedInt = .I64 }),
            .value = fd(2, .{ .FixedInt = .I64 }),
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// A representation of an exemplar, which is a sample input measurement.
// Exemplars also hold information about the environment when the measurement
// was recorded, for example the span and trace ID of the active span when the
// exemplar was recorded.
pub const Exemplar = struct {
    filtered_attributes: ArrayList(opentelemetry_proto_common_v1.KeyValue),
    time_unix_nano: u64 = 0,
    span_id: ManagedString = .Empty,
    trace_id: ManagedString = .Empty,
    value: ?value_union,

    pub const _value_case = enum {
        as_double,
        as_int,
    };
    pub const value_union = union(_value_case) {
        as_double: f64,
        as_int: i64,
        pub const _union_desc = .{
            .as_double = fd(3, .{ .FixedInt = .I64 }),
            .as_int = fd(6, .{ .FixedInt = .I64 }),
        };
    };

    pub const _desc_table = .{
        .filtered_attributes = fd(7, .{ .List = .{ .SubMessage = {} } }),
        .time_unix_nano = fd(2, .{ .FixedInt = .I64 }),
        .span_id = fd(4, .Bytes),
        .trace_id = fd(5, .Bytes),
        .value = fd(null, .{ .OneOf = value_union }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};
