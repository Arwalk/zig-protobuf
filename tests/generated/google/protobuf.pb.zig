// Code generated by protoc-gen-zig
///! package google.protobuf
const std = @import("std");
const Allocator = std.mem.Allocator;
const ArrayList = std.ArrayList;

const protobuf = @import("protobuf");
const ManagedString = protobuf.ManagedString;
const fd = protobuf.fd;
const ManagedStruct = protobuf.ManagedStruct;
const json = protobuf.json;
const UnionDecodingError = protobuf.UnionDecodingError;

// The protocol compiler can output a FileDescriptorSet containing the .proto
// files it parses.
pub const FileDescriptorSet = struct {
    file: ArrayList(FileDescriptorProto),

    pub const _desc_table = .{
        .file = fd(1, .{ .List = .{ .SubMessage = {} } }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Describes a complete .proto file.
pub const FileDescriptorProto = struct {
    name: ?ManagedString = null,
    package: ?ManagedString = null,
    dependency: ArrayList(ManagedString),
    public_dependency: ArrayList(i32),
    weak_dependency: ArrayList(i32),
    message_type: ArrayList(DescriptorProto),
    enum_type: ArrayList(EnumDescriptorProto),
    service: ArrayList(ServiceDescriptorProto),
    extension: ArrayList(FieldDescriptorProto),
    options: ?FileOptions = null,
    source_code_info: ?SourceCodeInfo = null,
    syntax: ?ManagedString = null,
    edition: ?ManagedString = null,

    pub const _desc_table = .{
        .name = fd(1, .String),
        .package = fd(2, .String),
        .dependency = fd(3, .{ .List = .String }),
        .public_dependency = fd(10, .{ .List = .{ .Varint = .Simple } }),
        .weak_dependency = fd(11, .{ .List = .{ .Varint = .Simple } }),
        .message_type = fd(4, .{ .List = .{ .SubMessage = {} } }),
        .enum_type = fd(5, .{ .List = .{ .SubMessage = {} } }),
        .service = fd(6, .{ .List = .{ .SubMessage = {} } }),
        .extension = fd(7, .{ .List = .{ .SubMessage = {} } }),
        .options = fd(8, .{ .SubMessage = {} }),
        .source_code_info = fd(9, .{ .SubMessage = {} }),
        .syntax = fd(12, .String),
        .edition = fd(13, .String),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Describes a message type.
pub const DescriptorProto = struct {
    name: ?ManagedString = null,
    field: ArrayList(FieldDescriptorProto),
    extension: ArrayList(FieldDescriptorProto),
    nested_type: ArrayList(DescriptorProto),
    enum_type: ArrayList(EnumDescriptorProto),
    extension_range: ArrayList(DescriptorProto.ExtensionRange),
    oneof_decl: ArrayList(OneofDescriptorProto),
    options: ?MessageOptions = null,
    reserved_range: ArrayList(DescriptorProto.ReservedRange),
    reserved_name: ArrayList(ManagedString),

    pub const _desc_table = .{
        .name = fd(1, .String),
        .field = fd(2, .{ .List = .{ .SubMessage = {} } }),
        .extension = fd(6, .{ .List = .{ .SubMessage = {} } }),
        .nested_type = fd(3, .{ .List = .{ .SubMessage = {} } }),
        .enum_type = fd(4, .{ .List = .{ .SubMessage = {} } }),
        .extension_range = fd(5, .{ .List = .{ .SubMessage = {} } }),
        .oneof_decl = fd(8, .{ .List = .{ .SubMessage = {} } }),
        .options = fd(7, .{ .SubMessage = {} }),
        .reserved_range = fd(9, .{ .List = .{ .SubMessage = {} } }),
        .reserved_name = fd(10, .{ .List = .String }),
    };

    pub const ExtensionRange = struct {
        start: ?i32 = null,
        end: ?i32 = null,
        options: ?ExtensionRangeOptions = null,

        pub const _desc_table = .{
            .start = fd(1, .{ .Varint = .Simple }),
            .end = fd(2, .{ .Varint = .Simple }),
            .options = fd(3, .{ .SubMessage = {} }),
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    // Range of reserved tag numbers. Reserved tag numbers may not be used by
    // fields or extension ranges in the same message. Reserved ranges may
    // not overlap.
    pub const ReservedRange = struct {
        start: ?i32 = null,
        end: ?i32 = null,

        pub const _desc_table = .{
            .start = fd(1, .{ .Varint = .Simple }),
            .end = fd(2, .{ .Varint = .Simple }),
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

pub const ExtensionRangeOptions = struct {
    uninterpreted_option: ArrayList(UninterpretedOption),
    declaration: ArrayList(ExtensionRangeOptions.Declaration),
    verification: ?ExtensionRangeOptions.VerificationState = .UNVERIFIED,

    pub const _desc_table = .{
        .uninterpreted_option = fd(999, .{ .List = .{ .SubMessage = {} } }),
        .declaration = fd(2, .{ .List = .{ .SubMessage = {} } }),
        .verification = fd(3, .{ .Varint = .Simple }),
    };

    // The verification state of the extension range.
    pub const VerificationState = enum(i32) {
        // All the extensions of the range must be declared.
        DECLARATION = 0,
        UNVERIFIED = 1,
        _,
    };

    pub const Declaration = struct {
        number: ?i32 = null,
        full_name: ?ManagedString = null,
        type: ?ManagedString = null,
        is_repeated: ?bool = null,
        reserved: ?bool = null,
        repeated: ?bool = null,

        pub const _desc_table = .{
            .number = fd(1, .{ .Varint = .Simple }),
            .full_name = fd(2, .String),
            .type = fd(3, .String),
            .is_repeated = fd(4, .{ .Varint = .Simple }),
            .reserved = fd(5, .{ .Varint = .Simple }),
            .repeated = fd(6, .{ .Varint = .Simple }),
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Describes a field within a message.
pub const FieldDescriptorProto = struct {
    name: ?ManagedString = null,
    number: ?i32 = null,
    label: ?FieldDescriptorProto.Label = null,
    type: ?FieldDescriptorProto.Type = null,
    type_name: ?ManagedString = null,
    extendee: ?ManagedString = null,
    default_value: ?ManagedString = null,
    oneof_index: ?i32 = null,
    json_name: ?ManagedString = null,
    options: ?FieldOptions = null,
    proto3_optional: ?bool = null,

    pub const _desc_table = .{
        .name = fd(1, .String),
        .number = fd(3, .{ .Varint = .Simple }),
        .label = fd(4, .{ .Varint = .Simple }),
        .type = fd(5, .{ .Varint = .Simple }),
        .type_name = fd(6, .String),
        .extendee = fd(2, .String),
        .default_value = fd(7, .String),
        .oneof_index = fd(9, .{ .Varint = .Simple }),
        .json_name = fd(10, .String),
        .options = fd(8, .{ .SubMessage = {} }),
        .proto3_optional = fd(17, .{ .Varint = .Simple }),
    };

    pub const Type = enum(i32) {
        // 0 is reserved for errors.
        // Order is weird for historical reasons.
        TYPE_DOUBLE = 1,
        TYPE_FLOAT = 2,
        // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
        // negative values are likely.
        TYPE_INT64 = 3,
        TYPE_UINT64 = 4,
        // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
        // negative values are likely.
        TYPE_INT32 = 5,
        TYPE_FIXED64 = 6,
        TYPE_FIXED32 = 7,
        TYPE_BOOL = 8,
        TYPE_STRING = 9,
        // Tag-delimited aggregate.
        // Group type is deprecated and not supported in proto3. However, Proto3
        // implementations should still be able to parse the group wire format and
        // treat group fields as unknown fields.
        TYPE_GROUP = 10,
        TYPE_MESSAGE = 11,
        // New in version 2.
        TYPE_BYTES = 12,
        TYPE_UINT32 = 13,
        TYPE_ENUM = 14,
        TYPE_SFIXED32 = 15,
        TYPE_SFIXED64 = 16,
        TYPE_SINT32 = 17,
        TYPE_SINT64 = 18,
        _,
    };

    pub const Label = enum(i32) {
        // 0 is reserved for errors
        LABEL_OPTIONAL = 1,
        LABEL_REQUIRED = 2,
        LABEL_REPEATED = 3,
        _,
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Describes a oneof.
pub const OneofDescriptorProto = struct {
    name: ?ManagedString = null,
    options: ?OneofOptions = null,

    pub const _desc_table = .{
        .name = fd(1, .String),
        .options = fd(2, .{ .SubMessage = {} }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Describes an enum type.
pub const EnumDescriptorProto = struct {
    name: ?ManagedString = null,
    value: ArrayList(EnumValueDescriptorProto),
    options: ?EnumOptions = null,
    reserved_range: ArrayList(EnumDescriptorProto.EnumReservedRange),
    reserved_name: ArrayList(ManagedString),

    pub const _desc_table = .{
        .name = fd(1, .String),
        .value = fd(2, .{ .List = .{ .SubMessage = {} } }),
        .options = fd(3, .{ .SubMessage = {} }),
        .reserved_range = fd(4, .{ .List = .{ .SubMessage = {} } }),
        .reserved_name = fd(5, .{ .List = .String }),
    };

    // Range of reserved numeric values. Reserved values may not be used by
    // entries in the same enum. Reserved ranges may not overlap.
    //
    // Note that this is distinct from DescriptorProto.ReservedRange in that it
    // is inclusive such that it can appropriately represent the entire int32
    // domain.
    pub const EnumReservedRange = struct {
        start: ?i32 = null,
        end: ?i32 = null,

        pub const _desc_table = .{
            .start = fd(1, .{ .Varint = .Simple }),
            .end = fd(2, .{ .Varint = .Simple }),
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Describes a value within an enum.
pub const EnumValueDescriptorProto = struct {
    name: ?ManagedString = null,
    number: ?i32 = null,
    options: ?EnumValueOptions = null,

    pub const _desc_table = .{
        .name = fd(1, .String),
        .number = fd(2, .{ .Varint = .Simple }),
        .options = fd(3, .{ .SubMessage = {} }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Describes a service.
pub const ServiceDescriptorProto = struct {
    name: ?ManagedString = null,
    method: ArrayList(MethodDescriptorProto),
    options: ?ServiceOptions = null,

    pub const _desc_table = .{
        .name = fd(1, .String),
        .method = fd(2, .{ .List = .{ .SubMessage = {} } }),
        .options = fd(3, .{ .SubMessage = {} }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Describes a method of a service.
pub const MethodDescriptorProto = struct {
    name: ?ManagedString = null,
    input_type: ?ManagedString = null,
    output_type: ?ManagedString = null,
    options: ?MethodOptions = null,
    client_streaming: ?bool = false,
    server_streaming: ?bool = false,

    pub const _desc_table = .{
        .name = fd(1, .String),
        .input_type = fd(2, .String),
        .output_type = fd(3, .String),
        .options = fd(4, .{ .SubMessage = {} }),
        .client_streaming = fd(5, .{ .Varint = .Simple }),
        .server_streaming = fd(6, .{ .Varint = .Simple }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

pub const FileOptions = struct {
    java_package: ?ManagedString = null,
    java_outer_classname: ?ManagedString = null,
    java_multiple_files: ?bool = false,
    java_generate_equals_and_hash: ?bool = null,
    java_string_check_utf8: ?bool = false,
    optimize_for: ?FileOptions.OptimizeMode = .SPEED,
    go_package: ?ManagedString = null,
    cc_generic_services: ?bool = false,
    java_generic_services: ?bool = false,
    py_generic_services: ?bool = false,
    php_generic_services: ?bool = false,
    deprecated: ?bool = false,
    cc_enable_arenas: ?bool = true,
    objc_class_prefix: ?ManagedString = null,
    csharp_namespace: ?ManagedString = null,
    swift_prefix: ?ManagedString = null,
    php_class_prefix: ?ManagedString = null,
    php_namespace: ?ManagedString = null,
    php_metadata_namespace: ?ManagedString = null,
    ruby_package: ?ManagedString = null,
    uninterpreted_option: ArrayList(UninterpretedOption),

    pub const _desc_table = .{
        .java_package = fd(1, .String),
        .java_outer_classname = fd(8, .String),
        .java_multiple_files = fd(10, .{ .Varint = .Simple }),
        .java_generate_equals_and_hash = fd(20, .{ .Varint = .Simple }),
        .java_string_check_utf8 = fd(27, .{ .Varint = .Simple }),
        .optimize_for = fd(9, .{ .Varint = .Simple }),
        .go_package = fd(11, .String),
        .cc_generic_services = fd(16, .{ .Varint = .Simple }),
        .java_generic_services = fd(17, .{ .Varint = .Simple }),
        .py_generic_services = fd(18, .{ .Varint = .Simple }),
        .php_generic_services = fd(42, .{ .Varint = .Simple }),
        .deprecated = fd(23, .{ .Varint = .Simple }),
        .cc_enable_arenas = fd(31, .{ .Varint = .Simple }),
        .objc_class_prefix = fd(36, .String),
        .csharp_namespace = fd(37, .String),
        .swift_prefix = fd(39, .String),
        .php_class_prefix = fd(40, .String),
        .php_namespace = fd(41, .String),
        .php_metadata_namespace = fd(44, .String),
        .ruby_package = fd(45, .String),
        .uninterpreted_option = fd(999, .{ .List = .{ .SubMessage = {} } }),
    };

    // Generated classes can be optimized for speed or code size.
    pub const OptimizeMode = enum(i32) {
        SPEED = 1,
        // etc.
        CODE_SIZE = 2,
        LITE_RUNTIME = 3,
        _,
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

pub const MessageOptions = struct {
    message_set_wire_format: ?bool = false,
    no_standard_descriptor_accessor: ?bool = false,
    deprecated: ?bool = false,
    map_entry: ?bool = null,
    deprecated_legacy_json_field_conflicts: ?bool = null,
    uninterpreted_option: ArrayList(UninterpretedOption),

    pub const _desc_table = .{
        .message_set_wire_format = fd(1, .{ .Varint = .Simple }),
        .no_standard_descriptor_accessor = fd(2, .{ .Varint = .Simple }),
        .deprecated = fd(3, .{ .Varint = .Simple }),
        .map_entry = fd(7, .{ .Varint = .Simple }),
        .deprecated_legacy_json_field_conflicts = fd(11, .{ .Varint = .Simple }),
        .uninterpreted_option = fd(999, .{ .List = .{ .SubMessage = {} } }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

pub const FieldOptions = struct {
    ctype: ?FieldOptions.CType = .STRING,
    @"packed": ?bool = null,
    jstype: ?FieldOptions.JSType = .JS_NORMAL,
    lazy: ?bool = false,
    unverified_lazy: ?bool = false,
    deprecated: ?bool = false,
    weak: ?bool = false,
    debug_redact: ?bool = false,
    retention: ?FieldOptions.OptionRetention = null,
    target: ?FieldOptions.OptionTargetType = null,
    targets: ArrayList(FieldOptions.OptionTargetType),
    uninterpreted_option: ArrayList(UninterpretedOption),

    pub const _desc_table = .{
        .ctype = fd(1, .{ .Varint = .Simple }),
        .@"packed" = fd(2, .{ .Varint = .Simple }),
        .jstype = fd(6, .{ .Varint = .Simple }),
        .lazy = fd(5, .{ .Varint = .Simple }),
        .unverified_lazy = fd(15, .{ .Varint = .Simple }),
        .deprecated = fd(3, .{ .Varint = .Simple }),
        .weak = fd(10, .{ .Varint = .Simple }),
        .debug_redact = fd(16, .{ .Varint = .Simple }),
        .retention = fd(17, .{ .Varint = .Simple }),
        .target = fd(18, .{ .Varint = .Simple }),
        .targets = fd(19, .{ .List = .{ .Varint = .Simple } }),
        .uninterpreted_option = fd(999, .{ .List = .{ .SubMessage = {} } }),
    };

    pub const CType = enum(i32) {
        // Default mode.
        STRING = 0,
        // The option [ctype=CORD] may be applied to a non-repeated field of type
        // "bytes". It indicates that in C++, the data should be stored in a Cord
        // instead of a string.  For very large strings, this may reduce memory
        // fragmentation. It may also allow better performance when parsing from a
        // Cord, or when parsing with aliasing enabled, as the parsed Cord may then
        // alias the original buffer.
        CORD = 1,
        STRING_PIECE = 2,
        _,
    };

    pub const JSType = enum(i32) {
        // Use the default type.
        JS_NORMAL = 0,
        // Use JavaScript strings.
        JS_STRING = 1,
        // Use JavaScript numbers.
        JS_NUMBER = 2,
        _,
    };

    // If set to RETENTION_SOURCE, the option will be omitted from the binary.
    // Note: as of January 2023, support for this is in progress and does not yet
    // have an effect (b/264593489).
    pub const OptionRetention = enum(i32) {
        RETENTION_UNKNOWN = 0,
        RETENTION_RUNTIME = 1,
        RETENTION_SOURCE = 2,
        _,
    };

    // This indicates the types of entities that the field may apply to when used
    // as an option. If it is unset, then the field may be freely used as an
    // option on any kind of entity. Note: as of January 2023, support for this is
    // in progress and does not yet have an effect (b/264593489).
    pub const OptionTargetType = enum(i32) {
        TARGET_TYPE_UNKNOWN = 0,
        TARGET_TYPE_FILE = 1,
        TARGET_TYPE_EXTENSION_RANGE = 2,
        TARGET_TYPE_MESSAGE = 3,
        TARGET_TYPE_FIELD = 4,
        TARGET_TYPE_ONEOF = 5,
        TARGET_TYPE_ENUM = 6,
        TARGET_TYPE_ENUM_ENTRY = 7,
        TARGET_TYPE_SERVICE = 8,
        TARGET_TYPE_METHOD = 9,
        _,
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

pub const OneofOptions = struct {
    uninterpreted_option: ArrayList(UninterpretedOption),

    pub const _desc_table = .{
        .uninterpreted_option = fd(999, .{ .List = .{ .SubMessage = {} } }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

pub const EnumOptions = struct {
    allow_alias: ?bool = null,
    deprecated: ?bool = false,
    deprecated_legacy_json_field_conflicts: ?bool = null,
    uninterpreted_option: ArrayList(UninterpretedOption),

    pub const _desc_table = .{
        .allow_alias = fd(2, .{ .Varint = .Simple }),
        .deprecated = fd(3, .{ .Varint = .Simple }),
        .deprecated_legacy_json_field_conflicts = fd(6, .{ .Varint = .Simple }),
        .uninterpreted_option = fd(999, .{ .List = .{ .SubMessage = {} } }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

pub const EnumValueOptions = struct {
    deprecated: ?bool = false,
    uninterpreted_option: ArrayList(UninterpretedOption),

    pub const _desc_table = .{
        .deprecated = fd(1, .{ .Varint = .Simple }),
        .uninterpreted_option = fd(999, .{ .List = .{ .SubMessage = {} } }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

pub const ServiceOptions = struct {
    deprecated: ?bool = false,
    uninterpreted_option: ArrayList(UninterpretedOption),

    pub const _desc_table = .{
        .deprecated = fd(33, .{ .Varint = .Simple }),
        .uninterpreted_option = fd(999, .{ .List = .{ .SubMessage = {} } }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

pub const MethodOptions = struct {
    deprecated: ?bool = false,
    idempotency_level: ?MethodOptions.IdempotencyLevel = .IDEMPOTENCY_UNKNOWN,
    uninterpreted_option: ArrayList(UninterpretedOption),

    pub const _desc_table = .{
        .deprecated = fd(33, .{ .Varint = .Simple }),
        .idempotency_level = fd(34, .{ .Varint = .Simple }),
        .uninterpreted_option = fd(999, .{ .List = .{ .SubMessage = {} } }),
    };

    // Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
    // or neither? HTTP based RPC implementation may choose GET verb for safe
    // methods, and PUT verb for idempotent methods instead of the default POST.
    pub const IdempotencyLevel = enum(i32) {
        IDEMPOTENCY_UNKNOWN = 0,
        NO_SIDE_EFFECTS = 1,
        IDEMPOTENT = 2,
        _,
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// A message representing a option the parser does not recognize. This only
// appears in options protos created by the compiler::Parser class.
// DescriptorPool resolves these when building Descriptor objects. Therefore,
// options protos in descriptor objects (e.g. returned by Descriptor::options(),
// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
// in them.
pub const UninterpretedOption = struct {
    name: ArrayList(UninterpretedOption.NamePart),
    identifier_value: ?ManagedString = null,
    positive_int_value: ?u64 = null,
    negative_int_value: ?i64 = null,
    double_value: ?f64 = null,
    string_value: ?ManagedString = null,
    aggregate_value: ?ManagedString = null,

    pub const _desc_table = .{
        .name = fd(2, .{ .List = .{ .SubMessage = {} } }),
        .identifier_value = fd(3, .String),
        .positive_int_value = fd(4, .{ .Varint = .Simple }),
        .negative_int_value = fd(5, .{ .Varint = .Simple }),
        .double_value = fd(6, .{ .FixedInt = .I64 }),
        .string_value = fd(7, .Bytes),
        .aggregate_value = fd(8, .String),
    };

    // The name of the uninterpreted option.  Each string represents a segment in
    // a dot-separated name.  is_extension is true iff a segment represents an
    // extension (denoted with parentheses in options specs in .proto files).
    // E.g.,{ ["foo", false], ["bar.baz", true], ["moo", false] } represents
    // "foo.(bar.baz).moo".
    pub const NamePart = struct {
        name_part: ManagedString,
        is_extension: bool,

        pub const _desc_table = .{
            .name_part = fd(1, .String),
            .is_extension = fd(2, .{ .Varint = .Simple }),
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Encapsulates information about the original source file from which a
// FileDescriptorProto was generated.
pub const SourceCodeInfo = struct {
    location: ArrayList(SourceCodeInfo.Location),

    pub const _desc_table = .{
        .location = fd(1, .{ .List = .{ .SubMessage = {} } }),
    };

    pub const Location = struct {
        path: ArrayList(i32),
        span: ArrayList(i32),
        leading_comments: ?ManagedString = null,
        trailing_comments: ?ManagedString = null,
        leading_detached_comments: ArrayList(ManagedString),

        pub const _desc_table = .{
            .path = fd(1, .{ .PackedList = .{ .Varint = .Simple } }),
            .span = fd(2, .{ .PackedList = .{ .Varint = .Simple } }),
            .leading_comments = fd(3, .String),
            .trailing_comments = fd(4, .String),
            .leading_detached_comments = fd(6, .{ .List = .String }),
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Describes the relationship between generated code and its original source
// file. A GeneratedCodeInfo message is associated with only one generated
// source file, but may contain references to different source .proto files.
pub const GeneratedCodeInfo = struct {
    annotation: ArrayList(GeneratedCodeInfo.Annotation),

    pub const _desc_table = .{
        .annotation = fd(1, .{ .List = .{ .SubMessage = {} } }),
    };

    pub const Annotation = struct {
        path: ArrayList(i32),
        source_file: ?ManagedString = null,
        begin: ?i32 = null,
        end: ?i32 = null,
        semantic: ?GeneratedCodeInfo.Annotation.Semantic = null,

        pub const _desc_table = .{
            .path = fd(1, .{ .PackedList = .{ .Varint = .Simple } }),
            .source_file = fd(2, .String),
            .begin = fd(3, .{ .Varint = .Simple }),
            .end = fd(4, .{ .Varint = .Simple }),
            .semantic = fd(5, .{ .Varint = .Simple }),
        };

        // Represents the identified object's effect on the element in the original
        // .proto file.
        pub const Semantic = enum(i32) {
            // There is no effect or the effect is indescribable.
            NONE = 0,
            // The element is set or otherwise mutated.
            SET = 1,
            // An alias to the element is returned.
            ALIAS = 2,
            _,
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// `Any` contains an arbitrary serialized protocol buffer message along with a
// URL that describes the type of the serialized message.
//
// Protobuf library provides support to pack/unpack Any values in the form
// of utility functions or additional generated methods of the Any type.
//
// Example 1: Pack and unpack a message in C++.
//
//     Foo foo = ...;
//     Any any;
//     any.PackFrom(foo);
//     ...
//     if (any.UnpackTo(&foo)) {
//       ...
//     }
//
// Example 2: Pack and unpack a message in Java.
//
//     Foo foo = ...;
//     Any any = Any.pack(foo);
//     ...
//     if (any.is(Foo.class)) {
//       foo = any.unpack(Foo.class);
//     }
//     // or ...
//     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
//       foo = any.unpack(Foo.getDefaultInstance());
//     }
//
//  Example 3: Pack and unpack a message in Python.
//
//     foo = Foo(...)
//     any = Any()
//     any.Pack(foo)
//     ...
//     if any.Is(Foo.DESCRIPTOR):
//       any.Unpack(foo)
//       ...
//
//  Example 4: Pack and unpack a message in Go
//
//      foo := &pb.Foo{...}
//      any, err := anypb.New(foo)
//      if err != nil {
//        ...
//      }
//      ...
//      foo := &pb.Foo{}
//      if err := any.UnmarshalTo(foo); err != nil {
//        ...
//      }
//
// The pack methods provided by protobuf library will by default use
// 'type.googleapis.com/full.type.name' as the type URL and the unpack
// methods only use the fully qualified type name after the last '/'
// in the type URL, for example "foo.bar.com/x/y.z" will yield type
// name "y.z".
//
// JSON
// ====
// The JSON representation of an `Any` value uses the regular
// representation of the deserialized, embedded message, with an
// additional field `@type` which contains the type URL. Example:
//
//     package google.profile;
//     message Person {
//       string first_name = 1;
//       string last_name = 2;
//     }
//
//     {
//       "@type": "type.googleapis.com/google.profile.Person",
//       "firstName": <string>,
//       "lastName": <string>
//     }
//
// If the embedded message type is well-known and has a custom JSON
// representation, that representation will be embedded adding a field
// `value` which holds the custom JSON in addition to the `@type`
// field. Example (for message [google.protobuf.Duration][]):
//
//     {
//       "@type": "type.googleapis.com/google.protobuf.Duration",
//       "value": "1.212s"
//     }
pub const Any = struct {
    type_url: ManagedString = .Empty,
    value: ManagedString = .Empty,

    pub const _desc_table = .{
        .type_url = fd(1, .String),
        .value = fd(2, .Bytes),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// A Duration represents a signed, fixed-length span of time represented
// as a count of seconds and fractions of seconds at nanosecond
// resolution. It is independent of any calendar and concepts like "day"
// or "month". It is related to Timestamp in that the difference between
// two Timestamp values is a Duration and it can be added or subtracted
// from a Timestamp. Range is approximately +-10,000 years.
//
// # Examples
//
// Example 1: Compute Duration from two Timestamps in pseudo code.
//
//     Timestamp start = ...;
//     Timestamp end = ...;
//     Duration duration = ...;
//
//     duration.seconds = end.seconds - start.seconds;
//     duration.nanos = end.nanos - start.nanos;
//
//     if (duration.seconds < 0 && duration.nanos > 0) {
//       duration.seconds += 1;
//       duration.nanos -= 1000000000;
//     } else if (duration.seconds > 0 && duration.nanos < 0) {
//       duration.seconds -= 1;
//       duration.nanos += 1000000000;
//     }
//
// Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
//
//     Timestamp start = ...;
//     Duration duration = ...;
//     Timestamp end = ...;
//
//     end.seconds = start.seconds + duration.seconds;
//     end.nanos = start.nanos + duration.nanos;
//
//     if (end.nanos < 0) {
//       end.seconds -= 1;
//       end.nanos += 1000000000;
//     } else if (end.nanos >= 1000000000) {
//       end.seconds += 1;
//       end.nanos -= 1000000000;
//     }
//
// Example 3: Compute Duration from datetime.timedelta in Python.
//
//     td = datetime.timedelta(days=3, minutes=10)
//     duration = Duration()
//     duration.FromTimedelta(td)
//
// # JSON Mapping
//
// In JSON format, the Duration type is encoded as a string rather than an
// object, where the string ends in the suffix "s" (indicating seconds) and
// is preceded by the number of seconds, with nanoseconds expressed as
// fractional seconds. For example, 3 seconds with 0 nanoseconds should be
// encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
// be expressed in JSON format as "3.000000001s", and 3 seconds and 1
// microsecond should be expressed in JSON format as "3.000001s".
pub const Duration = struct {
    seconds: i64 = 0,
    nanos: i32 = 0,

    pub const _desc_table = .{
        .seconds = fd(1, .{ .Varint = .Simple }),
        .nanos = fd(2, .{ .Varint = .Simple }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// `FieldMask` represents a set of symbolic field paths, for example:
//
//     paths: "f.a"
//     paths: "f.b.d"
//
// Here `f` represents a field in some root message, `a` and `b`
// fields in the message found in `f`, and `d` a field found in the
// message in `f.b`.
//
// Field masks are used to specify a subset of fields that should be
// returned by a get operation or modified by an update operation.
// Field masks also have a custom JSON encoding (see below).
//
// # Field Masks in Projections
//
// When used in the context of a projection, a response message or
// sub-message is filtered by the API to only contain those fields as
// specified in the mask. For example, if the mask in the previous
// example is applied to a response message as follows:
//
//     f {
//       a : 22
//       b {
//         d : 1
//         x : 2
//       }
//       y : 13
//     }
//     z: 8
//
// The result will not contain specific values for fields x,y and z
// (their value will be set to the default, and omitted in proto text
// output):
//
//
//     f {
//       a : 22
//       b {
//         d : 1
//       }
//     }
//
// A repeated field is not allowed except at the last position of a
// paths string.
//
// If a FieldMask object is not present in a get operation, the
// operation applies to all fields (as if a FieldMask of all fields
// had been specified).
//
// Note that a field mask does not necessarily apply to the
// top-level response message. In case of a REST get operation, the
// field mask applies directly to the response, but in case of a REST
// list operation, the mask instead applies to each individual message
// in the returned resource list. In case of a REST custom method,
// other definitions may be used. Where the mask applies will be
// clearly documented together with its declaration in the API.  In
// any case, the effect on the returned resource/resources is required
// behavior for APIs.
//
// # Field Masks in Update Operations
//
// A field mask in update operations specifies which fields of the
// targeted resource are going to be updated. The API is required
// to only change the values of the fields as specified in the mask
// and leave the others untouched. If a resource is passed in to
// describe the updated values, the API ignores the values of all
// fields not covered by the mask.
//
// If a repeated field is specified for an update operation, new values will
// be appended to the existing repeated field in the target resource. Note that
// a repeated field is only allowed in the last position of a `paths` string.
//
// If a sub-message is specified in the last position of the field mask for an
// update operation, then new value will be merged into the existing sub-message
// in the target resource.
//
// For example, given the target message:
//
//     f {
//       b {
//         d: 1
//         x: 2
//       }
//       c: [1]
//     }
//
// And an update message:
//
//     f {
//       b {
//         d: 10
//       }
//       c: [2]
//     }
//
// then if the field mask is:
//
//  paths: ["f.b", "f.c"]
//
// then the result will be:
//
//     f {
//       b {
//         d: 10
//         x: 2
//       }
//       c: [1, 2]
//     }
//
// An implementation may provide options to override this default behavior for
// repeated and message fields.
//
// In order to reset a field's value to the default, the field must
// be in the mask and set to the default value in the provided resource.
// Hence, in order to reset all fields of a resource, provide a default
// instance of the resource and set all fields in the mask, or do
// not provide a mask as described below.
//
// If a field mask is not present on update, the operation applies to
// all fields (as if a field mask of all fields has been specified).
// Note that in the presence of schema evolution, this may mean that
// fields the client does not know and has therefore not filled into
// the request will be reset to their default. If this is unwanted
// behavior, a specific service may require a client to always specify
// a field mask, producing an error if not.
//
// As with get operations, the location of the resource which
// describes the updated values in the request message depends on the
// operation kind. In any case, the effect of the field mask is
// required to be honored by the API.
//
// ## Considerations for HTTP REST
//
// The HTTP kind of an update operation which uses a field mask must
// be set to PATCH instead of PUT in order to satisfy HTTP semantics
// (PUT must only be used for full updates).
//
// # JSON Encoding of Field Masks
//
// In JSON, a field mask is encoded as a single string where paths are
// separated by a comma. Fields name in each path are converted
// to/from lower-camel naming conventions.
//
// As an example, consider the following message declarations:
//
//     message Profile {
//       User user = 1;
//       Photo photo = 2;
//     }
//     message User {
//       string display_name = 1;
//       string address = 2;
//     }
//
// In proto a field mask for `Profile` may look as such:
//
//     mask {
//       paths: "user.display_name"
//       paths: "photo"
//     }
//
// In JSON, the same mask is represented as below:
//
//     {
//       mask: "user.displayName,photo"
//     }
//
// # Field Masks and Oneof Fields
//
// Field masks treat fields in oneofs just as regular fields. Consider the
// following message:
//
//     message SampleMessage {
//       oneof test_oneof {
//         string name = 4;
//         SubMessage sub_message = 9;
//       }
//     }
//
// The field mask can be:
//
//     mask {
//       paths: "name"
//     }
//
// Or:
//
//     mask {
//       paths: "sub_message"
//     }
//
// Note that oneof type names ("test_oneof" in this case) cannot be used in
// paths.
//
// ## Field Mask Verification
//
// The implementation of any API method which has a FieldMask type field in the
// request should verify the included field paths, and return an
// `INVALID_ARGUMENT` error if any path is unmappable.
pub const FieldMask = struct {
    paths: ArrayList(ManagedString),

    pub const _desc_table = .{
        .paths = fd(1, .{ .List = .String }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// `NullValue` is a singleton enumeration to represent the null value for the
// `Value` type union.
//
// The JSON representation for `NullValue` is JSON `null`.
pub const NullValue = enum(i32) {
    // Null value.
    NULL_VALUE = 0,
    _,
};

// `Struct` represents a structured data value, consisting of fields
// which map to dynamically typed values. In some languages, `Struct`
// might be supported by a native representation. For example, in
// scripting languages like JS a struct is represented as an
// object. The details of that representation are described together
// with the proto support for the language.
//
// The JSON representation for `Struct` is JSON object.
pub const Struct = struct {
    fields: ArrayList(Struct.FieldsEntry),

    pub const _desc_table = .{
        .fields = fd(1, .{ .List = .{ .SubMessage = {} } }),
    };

    pub const FieldsEntry = struct {
        key: ManagedString = .Empty,
        value: ?Value = null,

        pub const _desc_table = .{
            .key = fd(1, .String),
            .value = fd(2, .{ .SubMessage = {} }),
        };

        pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
            return protobuf.pb_encode(self, allocator);
        }
        pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
            return protobuf.pb_decode(@This(), input, allocator);
        }
        pub fn init(allocator: Allocator) @This() {
            return protobuf.pb_init(@This(), allocator);
        }
        pub fn deinit(self: @This()) void {
            return protobuf.pb_deinit(self);
        }
        pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
            return protobuf.pb_dupe(@This(), self, allocator);
        }
        pub fn json_decode(
            input: []const u8,
            options: json.ParseOptions,
            allocator: Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.pb_json_decode(@This(), input, options, allocator);
        }
        pub fn json_encode(
            self: @This(),
            options: json.Stringify.Options,
            allocator: Allocator,
        ) ![]const u8 {
            return protobuf.pb_json_encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: Allocator,
            source: anytype,
            options: json.ParseOptions,
        ) !@This() {
            return protobuf.pb_json_parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.pb_jsonStringify(@This(), self, jws);
        }
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// `Value` represents a dynamically typed value which can be either
// null, a number, a string, a boolean, a recursive struct value, or a
// list of values. A producer of value is expected to set one of these
// variants. Absence of any variant indicates an error.
//
// The JSON representation for `Value` is JSON value.
pub const Value = struct {
    kind: ?kind_union,

    pub const _kind_case = enum {
        null_value,
        number_value,
        string_value,
        bool_value,
        struct_value,
        list_value,
    };
    pub const kind_union = union(_kind_case) {
        null_value: NullValue,
        number_value: f64,
        string_value: ManagedString,
        bool_value: bool,
        struct_value: Struct,
        list_value: ListValue,
        pub const _union_desc = .{
            .null_value = fd(1, .{ .Varint = .Simple }),
            .number_value = fd(2, .{ .FixedInt = .I64 }),
            .string_value = fd(3, .String),
            .bool_value = fd(4, .{ .Varint = .Simple }),
            .struct_value = fd(5, .{ .SubMessage = {} }),
            .list_value = fd(6, .{ .SubMessage = {} }),
        };
    };

    pub const _desc_table = .{
        .kind = fd(null, .{ .OneOf = kind_union }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// `ListValue` is a wrapper around a repeated field of values.
//
// The JSON representation for `ListValue` is JSON array.
pub const ListValue = struct {
    values: ArrayList(Value),

    pub const _desc_table = .{
        .values = fd(1, .{ .List = .{ .SubMessage = {} } }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// A Timestamp represents a point in time independent of any time zone or local
// calendar, encoded as a count of seconds and fractions of seconds at
// nanosecond resolution. The count is relative to an epoch at UTC midnight on
// January 1, 1970, in the proleptic Gregorian calendar which extends the
// Gregorian calendar backwards to year one.
//
// All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
// second table is needed for interpretation, using a [24-hour linear
// smear](https://developers.google.com/time/smear).
//
// The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
// restricting to that range, we ensure that we can convert to and from [RFC
// 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
//
// # Examples
//
// Example 1: Compute Timestamp from POSIX `time()`.
//
//     Timestamp timestamp;
//     timestamp.set_seconds(time(NULL));
//     timestamp.set_nanos(0);
//
// Example 2: Compute Timestamp from POSIX `gettimeofday()`.
//
//     struct timeval tv;
//     gettimeofday(&tv, NULL);
//
//     Timestamp timestamp;
//     timestamp.set_seconds(tv.tv_sec);
//     timestamp.set_nanos(tv.tv_usec * 1000);
//
// Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
//
//     FILETIME ft;
//     GetSystemTimeAsFileTime(&ft);
//     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
//
//     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
//     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
//     Timestamp timestamp;
//     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
//     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
//
// Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
//
//     long millis = System.currentTimeMillis();
//
//     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
//         .setNanos((int) ((millis % 1000) * 1000000)).build();
//
// Example 5: Compute Timestamp from Java `Instant.now()`.
//
//     Instant now = Instant.now();
//
//     Timestamp timestamp =
//         Timestamp.newBuilder().setSeconds(now.getEpochSecond())
//             .setNanos(now.getNano()).build();
//
// Example 6: Compute Timestamp from current time in Python.
//
//     timestamp = Timestamp()
//     timestamp.GetCurrentTime()
//
// # JSON Mapping
//
// In JSON format, the Timestamp type is encoded as a string in the
// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
// format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
// where {year} is always expressed using four digits while {month}, {day},
// {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
// seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
// are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
// is required. A proto3 JSON serializer should always use UTC (as indicated by
// "Z") when printing the Timestamp type and a proto3 JSON parser should be
// able to accept both UTC and other timezones (as indicated by an offset).
//
// For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
// 01:30 UTC on January 15, 2017.
//
// In JavaScript, one can convert a Date object to this format using the
// standard
// [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
// method. In Python, a standard `datetime.datetime` object can be converted
// to this format using
// [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
// the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
// the Joda Time's [`ISODateTimeFormat.dateTime()`](
// http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
// ) to obtain a formatter capable of generating timestamps in this format.
pub const Timestamp = struct {
    seconds: i64 = 0,
    nanos: i32 = 0,

    pub const _desc_table = .{
        .seconds = fd(1, .{ .Varint = .Simple }),
        .nanos = fd(2, .{ .Varint = .Simple }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Wrapper message for `double`.
//
// The JSON representation for `DoubleValue` is JSON number.
pub const DoubleValue = struct {
    value: f64 = 0,

    pub const _desc_table = .{
        .value = fd(1, .{ .FixedInt = .I64 }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Wrapper message for `float`.
//
// The JSON representation for `FloatValue` is JSON number.
pub const FloatValue = struct {
    value: f32 = 0,

    pub const _desc_table = .{
        .value = fd(1, .{ .FixedInt = .I32 }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Wrapper message for `int64`.
//
// The JSON representation for `Int64Value` is JSON string.
pub const Int64Value = struct {
    value: i64 = 0,

    pub const _desc_table = .{
        .value = fd(1, .{ .Varint = .Simple }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Wrapper message for `uint64`.
//
// The JSON representation for `UInt64Value` is JSON string.
pub const UInt64Value = struct {
    value: u64 = 0,

    pub const _desc_table = .{
        .value = fd(1, .{ .Varint = .Simple }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Wrapper message for `int32`.
//
// The JSON representation for `Int32Value` is JSON number.
pub const Int32Value = struct {
    value: i32 = 0,

    pub const _desc_table = .{
        .value = fd(1, .{ .Varint = .Simple }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Wrapper message for `uint32`.
//
// The JSON representation for `UInt32Value` is JSON number.
pub const UInt32Value = struct {
    value: u32 = 0,

    pub const _desc_table = .{
        .value = fd(1, .{ .Varint = .Simple }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Wrapper message for `bool`.
//
// The JSON representation for `BoolValue` is JSON `true` and `false`.
pub const BoolValue = struct {
    value: bool = false,

    pub const _desc_table = .{
        .value = fd(1, .{ .Varint = .Simple }),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Wrapper message for `string`.
//
// The JSON representation for `StringValue` is JSON string.
pub const StringValue = struct {
    value: ManagedString = .Empty,

    pub const _desc_table = .{
        .value = fd(1, .String),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};

// Wrapper message for `bytes`.
//
// The JSON representation for `BytesValue` is JSON string.
pub const BytesValue = struct {
    value: ManagedString = .Empty,

    pub const _desc_table = .{
        .value = fd(1, .Bytes),
    };

    pub fn encode(self: @This(), allocator: Allocator) Allocator.Error![]u8 {
        return protobuf.pb_encode(self, allocator);
    }
    pub fn decode(input: []const u8, allocator: Allocator) UnionDecodingError!@This() {
        return protobuf.pb_decode(@This(), input, allocator);
    }
    pub fn init(allocator: Allocator) @This() {
        return protobuf.pb_init(@This(), allocator);
    }
    pub fn deinit(self: @This()) void {
        return protobuf.pb_deinit(self);
    }
    pub fn dupe(self: @This(), allocator: Allocator) Allocator.Error!@This() {
        return protobuf.pb_dupe(@This(), self, allocator);
    }
    pub fn json_decode(
        input: []const u8,
        options: json.ParseOptions,
        allocator: Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.pb_json_decode(@This(), input, options, allocator);
    }
    pub fn json_encode(
        self: @This(),
        options: json.Stringify.Options,
        allocator: Allocator,
    ) ![]const u8 {
        return protobuf.pb_json_encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: Allocator,
        source: anytype,
        options: json.ParseOptions,
    ) !@This() {
        return protobuf.pb_json_parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.pb_jsonStringify(@This(), self, jws);
    }
};
