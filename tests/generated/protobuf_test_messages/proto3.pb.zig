// Code generated by protoc-gen-zig
///! package protobuf_test_messages.proto3
const std = @import("std");

const protobuf = @import("protobuf");
const fd = protobuf.fd;
/// import package google.protobuf
const google_protobuf = @import("../google/protobuf.pb.zig");

pub const ForeignEnum = enum(i32) {
    FOREIGN_FOO = 0,
    FOREIGN_BAR = 1,
    FOREIGN_BAZ = 2,
    _,
};

pub const TestAllTypesProto3 = struct {
    optional_int32: i32 = 0,
    optional_int64: i64 = 0,
    optional_uint32: u32 = 0,
    optional_uint64: u64 = 0,
    optional_sint32: i32 = 0,
    optional_sint64: i64 = 0,
    optional_fixed32: u32 = 0,
    optional_fixed64: u64 = 0,
    optional_sfixed32: i32 = 0,
    optional_sfixed64: i64 = 0,
    optional_float: f32 = 0,
    optional_double: f64 = 0,
    optional_bool: bool = false,
    optional_string: []const u8 = &.{},
    optional_bytes: []const u8 = &.{},
    optional_nested_message: ?TestAllTypesProto3.NestedMessage = null,
    optional_foreign_message: ?ForeignMessage = null,
    optional_nested_enum: TestAllTypesProto3.NestedEnum = @enumFromInt(0),
    optional_foreign_enum: ForeignEnum = @enumFromInt(0),
    optional_aliased_enum: TestAllTypesProto3.AliasedEnum = @enumFromInt(0),
    optional_string_piece: []const u8 = &.{},
    optional_cord: []const u8 = &.{},
    repeated_int32: std.ArrayListUnmanaged(i32) = .empty,
    repeated_int64: std.ArrayListUnmanaged(i64) = .empty,
    repeated_uint32: std.ArrayListUnmanaged(u32) = .empty,
    repeated_uint64: std.ArrayListUnmanaged(u64) = .empty,
    repeated_sint32: std.ArrayListUnmanaged(i32) = .empty,
    repeated_sint64: std.ArrayListUnmanaged(i64) = .empty,
    repeated_fixed32: std.ArrayListUnmanaged(u32) = .empty,
    repeated_fixed64: std.ArrayListUnmanaged(u64) = .empty,
    repeated_sfixed32: std.ArrayListUnmanaged(i32) = .empty,
    repeated_sfixed64: std.ArrayListUnmanaged(i64) = .empty,
    repeated_float: std.ArrayListUnmanaged(f32) = .empty,
    repeated_double: std.ArrayListUnmanaged(f64) = .empty,
    repeated_bool: std.ArrayListUnmanaged(bool) = .empty,
    repeated_string: std.ArrayListUnmanaged([]const u8) = .empty,
    repeated_bytes: std.ArrayListUnmanaged([]const u8) = .empty,
    repeated_nested_message: std.ArrayListUnmanaged(TestAllTypesProto3.NestedMessage) = .empty,
    repeated_foreign_message: std.ArrayListUnmanaged(ForeignMessage) = .empty,
    repeated_nested_enum: std.ArrayListUnmanaged(TestAllTypesProto3.NestedEnum) = .empty,
    repeated_foreign_enum: std.ArrayListUnmanaged(ForeignEnum) = .empty,
    repeated_string_piece: std.ArrayListUnmanaged([]const u8) = .empty,
    repeated_cord: std.ArrayListUnmanaged([]const u8) = .empty,
    packed_int32: std.ArrayListUnmanaged(i32) = .empty,
    packed_int64: std.ArrayListUnmanaged(i64) = .empty,
    packed_uint32: std.ArrayListUnmanaged(u32) = .empty,
    packed_uint64: std.ArrayListUnmanaged(u64) = .empty,
    packed_sint32: std.ArrayListUnmanaged(i32) = .empty,
    packed_sint64: std.ArrayListUnmanaged(i64) = .empty,
    packed_fixed32: std.ArrayListUnmanaged(u32) = .empty,
    packed_fixed64: std.ArrayListUnmanaged(u64) = .empty,
    packed_sfixed32: std.ArrayListUnmanaged(i32) = .empty,
    packed_sfixed64: std.ArrayListUnmanaged(i64) = .empty,
    packed_float: std.ArrayListUnmanaged(f32) = .empty,
    packed_double: std.ArrayListUnmanaged(f64) = .empty,
    packed_bool: std.ArrayListUnmanaged(bool) = .empty,
    packed_nested_enum: std.ArrayListUnmanaged(TestAllTypesProto3.NestedEnum) = .empty,
    unpacked_int32: std.ArrayListUnmanaged(i32) = .empty,
    unpacked_int64: std.ArrayListUnmanaged(i64) = .empty,
    unpacked_uint32: std.ArrayListUnmanaged(u32) = .empty,
    unpacked_uint64: std.ArrayListUnmanaged(u64) = .empty,
    unpacked_sint32: std.ArrayListUnmanaged(i32) = .empty,
    unpacked_sint64: std.ArrayListUnmanaged(i64) = .empty,
    unpacked_fixed32: std.ArrayListUnmanaged(u32) = .empty,
    unpacked_fixed64: std.ArrayListUnmanaged(u64) = .empty,
    unpacked_sfixed32: std.ArrayListUnmanaged(i32) = .empty,
    unpacked_sfixed64: std.ArrayListUnmanaged(i64) = .empty,
    unpacked_float: std.ArrayListUnmanaged(f32) = .empty,
    unpacked_double: std.ArrayListUnmanaged(f64) = .empty,
    unpacked_bool: std.ArrayListUnmanaged(bool) = .empty,
    unpacked_nested_enum: std.ArrayListUnmanaged(TestAllTypesProto3.NestedEnum) = .empty,
    map_int32_int32: std.ArrayListUnmanaged(TestAllTypesProto3.MapInt32Int32Entry) = .empty,
    map_int64_int64: std.ArrayListUnmanaged(TestAllTypesProto3.MapInt64Int64Entry) = .empty,
    map_uint32_uint32: std.ArrayListUnmanaged(TestAllTypesProto3.MapUint32Uint32Entry) = .empty,
    map_uint64_uint64: std.ArrayListUnmanaged(TestAllTypesProto3.MapUint64Uint64Entry) = .empty,
    map_sint32_sint32: std.ArrayListUnmanaged(TestAllTypesProto3.MapSint32Sint32Entry) = .empty,
    map_sint64_sint64: std.ArrayListUnmanaged(TestAllTypesProto3.MapSint64Sint64Entry) = .empty,
    map_fixed32_fixed32: std.ArrayListUnmanaged(TestAllTypesProto3.MapFixed32Fixed32Entry) = .empty,
    map_fixed64_fixed64: std.ArrayListUnmanaged(TestAllTypesProto3.MapFixed64Fixed64Entry) = .empty,
    map_sfixed32_sfixed32: std.ArrayListUnmanaged(TestAllTypesProto3.MapSfixed32Sfixed32Entry) = .empty,
    map_sfixed64_sfixed64: std.ArrayListUnmanaged(TestAllTypesProto3.MapSfixed64Sfixed64Entry) = .empty,
    map_int32_float: std.ArrayListUnmanaged(TestAllTypesProto3.MapInt32FloatEntry) = .empty,
    map_int32_double: std.ArrayListUnmanaged(TestAllTypesProto3.MapInt32DoubleEntry) = .empty,
    map_bool_bool: std.ArrayListUnmanaged(TestAllTypesProto3.MapBoolBoolEntry) = .empty,
    map_string_string: std.ArrayListUnmanaged(TestAllTypesProto3.MapStringStringEntry) = .empty,
    map_string_bytes: std.ArrayListUnmanaged(TestAllTypesProto3.MapStringBytesEntry) = .empty,
    map_string_nested_message: std.ArrayListUnmanaged(TestAllTypesProto3.MapStringNestedMessageEntry) = .empty,
    map_string_foreign_message: std.ArrayListUnmanaged(TestAllTypesProto3.MapStringForeignMessageEntry) = .empty,
    map_string_nested_enum: std.ArrayListUnmanaged(TestAllTypesProto3.MapStringNestedEnumEntry) = .empty,
    map_string_foreign_enum: std.ArrayListUnmanaged(TestAllTypesProto3.MapStringForeignEnumEntry) = .empty,
    optional_bool_wrapper: ?google_protobuf.BoolValue = null,
    optional_int32_wrapper: ?google_protobuf.Int32Value = null,
    optional_int64_wrapper: ?google_protobuf.Int64Value = null,
    optional_uint32_wrapper: ?google_protobuf.UInt32Value = null,
    optional_uint64_wrapper: ?google_protobuf.UInt64Value = null,
    optional_float_wrapper: ?google_protobuf.FloatValue = null,
    optional_double_wrapper: ?google_protobuf.DoubleValue = null,
    optional_string_wrapper: ?google_protobuf.StringValue = null,
    optional_bytes_wrapper: ?google_protobuf.BytesValue = null,
    repeated_bool_wrapper: std.ArrayListUnmanaged(google_protobuf.BoolValue) = .empty,
    repeated_int32_wrapper: std.ArrayListUnmanaged(google_protobuf.Int32Value) = .empty,
    repeated_int64_wrapper: std.ArrayListUnmanaged(google_protobuf.Int64Value) = .empty,
    repeated_uint32_wrapper: std.ArrayListUnmanaged(google_protobuf.UInt32Value) = .empty,
    repeated_uint64_wrapper: std.ArrayListUnmanaged(google_protobuf.UInt64Value) = .empty,
    repeated_float_wrapper: std.ArrayListUnmanaged(google_protobuf.FloatValue) = .empty,
    repeated_double_wrapper: std.ArrayListUnmanaged(google_protobuf.DoubleValue) = .empty,
    repeated_string_wrapper: std.ArrayListUnmanaged(google_protobuf.StringValue) = .empty,
    repeated_bytes_wrapper: std.ArrayListUnmanaged(google_protobuf.BytesValue) = .empty,
    optional_duration: ?google_protobuf.Duration = null,
    optional_timestamp: ?google_protobuf.Timestamp = null,
    optional_field_mask: ?google_protobuf.FieldMask = null,
    optional_struct: ?google_protobuf.Struct = null,
    optional_any: ?google_protobuf.Any = null,
    optional_value: ?google_protobuf.Value = null,
    optional_null_value: google_protobuf.NullValue = @enumFromInt(0),
    repeated_duration: std.ArrayListUnmanaged(google_protobuf.Duration) = .empty,
    repeated_timestamp: std.ArrayListUnmanaged(google_protobuf.Timestamp) = .empty,
    repeated_fieldmask: std.ArrayListUnmanaged(google_protobuf.FieldMask) = .empty,
    repeated_struct: std.ArrayListUnmanaged(google_protobuf.Struct) = .empty,
    repeated_any: std.ArrayListUnmanaged(google_protobuf.Any) = .empty,
    repeated_value: std.ArrayListUnmanaged(google_protobuf.Value) = .empty,
    repeated_list_value: std.ArrayListUnmanaged(google_protobuf.ListValue) = .empty,
    fieldname1: i32 = 0,
    field_name2: i32 = 0,
    _field_name3: i32 = 0,
    field__name4_: i32 = 0,
    field0name5: i32 = 0,
    field_0_name6: i32 = 0,
    fieldName7: i32 = 0,
    FieldName8: i32 = 0,
    field_Name9: i32 = 0,
    Field_Name10: i32 = 0,
    FIELD_NAME11: i32 = 0,
    FIELD_name12: i32 = 0,
    __field_name13: i32 = 0,
    __Field_name14: i32 = 0,
    field__name15: i32 = 0,
    field__Name16: i32 = 0,
    field_name17__: i32 = 0,
    Field_name18__: i32 = 0,
    oneof_field: ?oneof_field_union,

    pub const _oneof_field_case = enum {
        oneof_uint32,
        oneof_nested_message,
        oneof_string,
        oneof_bytes,
        oneof_bool,
        oneof_uint64,
        oneof_float,
        oneof_double,
        oneof_enum,
        oneof_null_value,
    };
    pub const oneof_field_union = union(_oneof_field_case) {
        oneof_uint32: u32,
        oneof_nested_message: TestAllTypesProto3.NestedMessage,
        oneof_string: []const u8,
        oneof_bytes: []const u8,
        oneof_bool: bool,
        oneof_uint64: u64,
        oneof_float: f32,
        oneof_double: f64,
        oneof_enum: TestAllTypesProto3.NestedEnum,
        oneof_null_value: google_protobuf.NullValue,
        pub const _desc_table = .{
            .oneof_uint32 = fd(111, .{ .scalar = .uint32 }),
            .oneof_nested_message = fd(112, .submessage),
            .oneof_string = fd(113, .{ .scalar = .string }),
            .oneof_bytes = fd(114, .{ .scalar = .bytes }),
            .oneof_bool = fd(115, .{ .scalar = .bool }),
            .oneof_uint64 = fd(116, .{ .scalar = .uint64 }),
            .oneof_float = fd(117, .{ .scalar = .float }),
            .oneof_double = fd(118, .{ .scalar = .double }),
            .oneof_enum = fd(119, .@"enum"),
            .oneof_null_value = fd(120, .@"enum"),
        };
    };

    pub const _desc_table = .{
        .optional_int32 = fd(1, .{ .scalar = .int32 }),
        .optional_int64 = fd(2, .{ .scalar = .int64 }),
        .optional_uint32 = fd(3, .{ .scalar = .uint32 }),
        .optional_uint64 = fd(4, .{ .scalar = .uint64 }),
        .optional_sint32 = fd(5, .{ .scalar = .sint32 }),
        .optional_sint64 = fd(6, .{ .scalar = .sint64 }),
        .optional_fixed32 = fd(7, .{ .scalar = .fixed32 }),
        .optional_fixed64 = fd(8, .{ .scalar = .fixed64 }),
        .optional_sfixed32 = fd(9, .{ .scalar = .sfixed32 }),
        .optional_sfixed64 = fd(10, .{ .scalar = .sfixed64 }),
        .optional_float = fd(11, .{ .scalar = .float }),
        .optional_double = fd(12, .{ .scalar = .double }),
        .optional_bool = fd(13, .{ .scalar = .bool }),
        .optional_string = fd(14, .{ .scalar = .string }),
        .optional_bytes = fd(15, .{ .scalar = .bytes }),
        .optional_nested_message = fd(18, .submessage),
        .optional_foreign_message = fd(19, .submessage),
        .optional_nested_enum = fd(21, .@"enum"),
        .optional_foreign_enum = fd(22, .@"enum"),
        .optional_aliased_enum = fd(23, .@"enum"),
        .optional_string_piece = fd(24, .{ .scalar = .string }),
        .optional_cord = fd(25, .{ .scalar = .string }),
        .repeated_int32 = fd(31, .{ .packed_repeated = .{ .scalar = .int32 } }),
        .repeated_int64 = fd(32, .{ .packed_repeated = .{ .scalar = .int64 } }),
        .repeated_uint32 = fd(33, .{ .packed_repeated = .{ .scalar = .uint32 } }),
        .repeated_uint64 = fd(34, .{ .packed_repeated = .{ .scalar = .uint64 } }),
        .repeated_sint32 = fd(35, .{ .packed_repeated = .{ .scalar = .sint32 } }),
        .repeated_sint64 = fd(36, .{ .packed_repeated = .{ .scalar = .sint64 } }),
        .repeated_fixed32 = fd(37, .{ .packed_repeated = .{ .scalar = .fixed32 } }),
        .repeated_fixed64 = fd(38, .{ .packed_repeated = .{ .scalar = .fixed64 } }),
        .repeated_sfixed32 = fd(39, .{ .packed_repeated = .{ .scalar = .sfixed32 } }),
        .repeated_sfixed64 = fd(40, .{ .packed_repeated = .{ .scalar = .sfixed64 } }),
        .repeated_float = fd(41, .{ .packed_repeated = .{ .scalar = .float } }),
        .repeated_double = fd(42, .{ .packed_repeated = .{ .scalar = .double } }),
        .repeated_bool = fd(43, .{ .packed_repeated = .{ .scalar = .bool } }),
        .repeated_string = fd(44, .{ .repeated = .{ .scalar = .string } }),
        .repeated_bytes = fd(45, .{ .repeated = .{ .scalar = .bytes } }),
        .repeated_nested_message = fd(48, .{ .repeated = .submessage }),
        .repeated_foreign_message = fd(49, .{ .repeated = .submessage }),
        .repeated_nested_enum = fd(51, .{ .repeated = .@"enum" }),
        .repeated_foreign_enum = fd(52, .{ .repeated = .@"enum" }),
        .repeated_string_piece = fd(54, .{ .repeated = .{ .scalar = .string } }),
        .repeated_cord = fd(55, .{ .repeated = .{ .scalar = .string } }),
        .packed_int32 = fd(75, .{ .packed_repeated = .{ .scalar = .int32 } }),
        .packed_int64 = fd(76, .{ .packed_repeated = .{ .scalar = .int64 } }),
        .packed_uint32 = fd(77, .{ .packed_repeated = .{ .scalar = .uint32 } }),
        .packed_uint64 = fd(78, .{ .packed_repeated = .{ .scalar = .uint64 } }),
        .packed_sint32 = fd(79, .{ .packed_repeated = .{ .scalar = .sint32 } }),
        .packed_sint64 = fd(80, .{ .packed_repeated = .{ .scalar = .sint64 } }),
        .packed_fixed32 = fd(81, .{ .packed_repeated = .{ .scalar = .fixed32 } }),
        .packed_fixed64 = fd(82, .{ .packed_repeated = .{ .scalar = .fixed64 } }),
        .packed_sfixed32 = fd(83, .{ .packed_repeated = .{ .scalar = .sfixed32 } }),
        .packed_sfixed64 = fd(84, .{ .packed_repeated = .{ .scalar = .sfixed64 } }),
        .packed_float = fd(85, .{ .packed_repeated = .{ .scalar = .float } }),
        .packed_double = fd(86, .{ .packed_repeated = .{ .scalar = .double } }),
        .packed_bool = fd(87, .{ .packed_repeated = .{ .scalar = .bool } }),
        .packed_nested_enum = fd(88, .{ .packed_repeated = .@"enum" }),
        .unpacked_int32 = fd(89, .{ .repeated = .{ .scalar = .int32 } }),
        .unpacked_int64 = fd(90, .{ .repeated = .{ .scalar = .int64 } }),
        .unpacked_uint32 = fd(91, .{ .repeated = .{ .scalar = .uint32 } }),
        .unpacked_uint64 = fd(92, .{ .repeated = .{ .scalar = .uint64 } }),
        .unpacked_sint32 = fd(93, .{ .repeated = .{ .scalar = .sint32 } }),
        .unpacked_sint64 = fd(94, .{ .repeated = .{ .scalar = .sint64 } }),
        .unpacked_fixed32 = fd(95, .{ .repeated = .{ .scalar = .fixed32 } }),
        .unpacked_fixed64 = fd(96, .{ .repeated = .{ .scalar = .fixed64 } }),
        .unpacked_sfixed32 = fd(97, .{ .repeated = .{ .scalar = .sfixed32 } }),
        .unpacked_sfixed64 = fd(98, .{ .repeated = .{ .scalar = .sfixed64 } }),
        .unpacked_float = fd(99, .{ .repeated = .{ .scalar = .float } }),
        .unpacked_double = fd(100, .{ .repeated = .{ .scalar = .double } }),
        .unpacked_bool = fd(101, .{ .repeated = .{ .scalar = .bool } }),
        .unpacked_nested_enum = fd(102, .{ .repeated = .@"enum" }),
        .map_int32_int32 = fd(56, .{ .repeated = .submessage }),
        .map_int64_int64 = fd(57, .{ .repeated = .submessage }),
        .map_uint32_uint32 = fd(58, .{ .repeated = .submessage }),
        .map_uint64_uint64 = fd(59, .{ .repeated = .submessage }),
        .map_sint32_sint32 = fd(60, .{ .repeated = .submessage }),
        .map_sint64_sint64 = fd(61, .{ .repeated = .submessage }),
        .map_fixed32_fixed32 = fd(62, .{ .repeated = .submessage }),
        .map_fixed64_fixed64 = fd(63, .{ .repeated = .submessage }),
        .map_sfixed32_sfixed32 = fd(64, .{ .repeated = .submessage }),
        .map_sfixed64_sfixed64 = fd(65, .{ .repeated = .submessage }),
        .map_int32_float = fd(66, .{ .repeated = .submessage }),
        .map_int32_double = fd(67, .{ .repeated = .submessage }),
        .map_bool_bool = fd(68, .{ .repeated = .submessage }),
        .map_string_string = fd(69, .{ .repeated = .submessage }),
        .map_string_bytes = fd(70, .{ .repeated = .submessage }),
        .map_string_nested_message = fd(71, .{ .repeated = .submessage }),
        .map_string_foreign_message = fd(72, .{ .repeated = .submessage }),
        .map_string_nested_enum = fd(73, .{ .repeated = .submessage }),
        .map_string_foreign_enum = fd(74, .{ .repeated = .submessage }),
        .optional_bool_wrapper = fd(201, .submessage),
        .optional_int32_wrapper = fd(202, .submessage),
        .optional_int64_wrapper = fd(203, .submessage),
        .optional_uint32_wrapper = fd(204, .submessage),
        .optional_uint64_wrapper = fd(205, .submessage),
        .optional_float_wrapper = fd(206, .submessage),
        .optional_double_wrapper = fd(207, .submessage),
        .optional_string_wrapper = fd(208, .submessage),
        .optional_bytes_wrapper = fd(209, .submessage),
        .repeated_bool_wrapper = fd(211, .{ .repeated = .submessage }),
        .repeated_int32_wrapper = fd(212, .{ .repeated = .submessage }),
        .repeated_int64_wrapper = fd(213, .{ .repeated = .submessage }),
        .repeated_uint32_wrapper = fd(214, .{ .repeated = .submessage }),
        .repeated_uint64_wrapper = fd(215, .{ .repeated = .submessage }),
        .repeated_float_wrapper = fd(216, .{ .repeated = .submessage }),
        .repeated_double_wrapper = fd(217, .{ .repeated = .submessage }),
        .repeated_string_wrapper = fd(218, .{ .repeated = .submessage }),
        .repeated_bytes_wrapper = fd(219, .{ .repeated = .submessage }),
        .optional_duration = fd(301, .submessage),
        .optional_timestamp = fd(302, .submessage),
        .optional_field_mask = fd(303, .submessage),
        .optional_struct = fd(304, .submessage),
        .optional_any = fd(305, .submessage),
        .optional_value = fd(306, .submessage),
        .optional_null_value = fd(307, .@"enum"),
        .repeated_duration = fd(311, .{ .repeated = .submessage }),
        .repeated_timestamp = fd(312, .{ .repeated = .submessage }),
        .repeated_fieldmask = fd(313, .{ .repeated = .submessage }),
        .repeated_struct = fd(324, .{ .repeated = .submessage }),
        .repeated_any = fd(315, .{ .repeated = .submessage }),
        .repeated_value = fd(316, .{ .repeated = .submessage }),
        .repeated_list_value = fd(317, .{ .repeated = .submessage }),
        .fieldname1 = fd(401, .{ .scalar = .int32 }),
        .field_name2 = fd(402, .{ .scalar = .int32 }),
        ._field_name3 = fd(403, .{ .scalar = .int32 }),
        .field__name4_ = fd(404, .{ .scalar = .int32 }),
        .field0name5 = fd(405, .{ .scalar = .int32 }),
        .field_0_name6 = fd(406, .{ .scalar = .int32 }),
        .fieldName7 = fd(407, .{ .scalar = .int32 }),
        .FieldName8 = fd(408, .{ .scalar = .int32 }),
        .field_Name9 = fd(409, .{ .scalar = .int32 }),
        .Field_Name10 = fd(410, .{ .scalar = .int32 }),
        .FIELD_NAME11 = fd(411, .{ .scalar = .int32 }),
        .FIELD_name12 = fd(412, .{ .scalar = .int32 }),
        .__field_name13 = fd(413, .{ .scalar = .int32 }),
        .__Field_name14 = fd(414, .{ .scalar = .int32 }),
        .field__name15 = fd(415, .{ .scalar = .int32 }),
        .field__Name16 = fd(416, .{ .scalar = .int32 }),
        .field_name17__ = fd(417, .{ .scalar = .int32 }),
        .Field_name18__ = fd(418, .{ .scalar = .int32 }),
        .oneof_field = fd(null, .{ .oneof = oneof_field_union }),
    };

    pub const NestedEnum = enum(i32) {
        FOO = 0,
        BAR = 1,
        BAZ = 2,
        NEG = -1,
        _,
    };

    pub const AliasedEnum = enum(i32) {
        ALIAS_FOO = 0,
        ALIAS_BAR = 1,
        MOO = 2,
        _,
    };

    pub const NestedMessage = struct {
        a: i32 = 0,

        pub const _desc_table = .{
            .a = fd(1, .{ .scalar = .int32 }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapInt32Int32Entry = struct {
        key: i32 = 0,
        value: i32 = 0,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .int32 }),
            .value = fd(2, .{ .scalar = .int32 }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapInt64Int64Entry = struct {
        key: i64 = 0,
        value: i64 = 0,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .int64 }),
            .value = fd(2, .{ .scalar = .int64 }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapUint32Uint32Entry = struct {
        key: u32 = 0,
        value: u32 = 0,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .uint32 }),
            .value = fd(2, .{ .scalar = .uint32 }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapUint64Uint64Entry = struct {
        key: u64 = 0,
        value: u64 = 0,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .uint64 }),
            .value = fd(2, .{ .scalar = .uint64 }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapSint32Sint32Entry = struct {
        key: i32 = 0,
        value: i32 = 0,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .sint32 }),
            .value = fd(2, .{ .scalar = .sint32 }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapSint64Sint64Entry = struct {
        key: i64 = 0,
        value: i64 = 0,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .sint64 }),
            .value = fd(2, .{ .scalar = .sint64 }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapFixed32Fixed32Entry = struct {
        key: u32 = 0,
        value: u32 = 0,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .fixed32 }),
            .value = fd(2, .{ .scalar = .fixed32 }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapFixed64Fixed64Entry = struct {
        key: u64 = 0,
        value: u64 = 0,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .fixed64 }),
            .value = fd(2, .{ .scalar = .fixed64 }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapSfixed32Sfixed32Entry = struct {
        key: i32 = 0,
        value: i32 = 0,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .sfixed32 }),
            .value = fd(2, .{ .scalar = .sfixed32 }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapSfixed64Sfixed64Entry = struct {
        key: i64 = 0,
        value: i64 = 0,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .sfixed64 }),
            .value = fd(2, .{ .scalar = .sfixed64 }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapInt32FloatEntry = struct {
        key: i32 = 0,
        value: f32 = 0,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .int32 }),
            .value = fd(2, .{ .scalar = .float }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapInt32DoubleEntry = struct {
        key: i32 = 0,
        value: f64 = 0,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .int32 }),
            .value = fd(2, .{ .scalar = .double }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapBoolBoolEntry = struct {
        key: bool = false,
        value: bool = false,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .bool }),
            .value = fd(2, .{ .scalar = .bool }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapStringStringEntry = struct {
        key: []const u8 = &.{},
        value: []const u8 = &.{},

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .string }),
            .value = fd(2, .{ .scalar = .string }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapStringBytesEntry = struct {
        key: []const u8 = &.{},
        value: []const u8 = &.{},

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .string }),
            .value = fd(2, .{ .scalar = .bytes }),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapStringNestedMessageEntry = struct {
        key: []const u8 = &.{},
        value: ?TestAllTypesProto3.NestedMessage = null,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .string }),
            .value = fd(2, .submessage),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapStringForeignMessageEntry = struct {
        key: []const u8 = &.{},
        value: ?ForeignMessage = null,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .string }),
            .value = fd(2, .submessage),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapStringNestedEnumEntry = struct {
        key: []const u8 = &.{},
        value: TestAllTypesProto3.NestedEnum = @enumFromInt(0),

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .string }),
            .value = fd(2, .@"enum"),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub const MapStringForeignEnumEntry = struct {
        key: []const u8 = &.{},
        value: ForeignEnum = @enumFromInt(0),

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .string }),
            .value = fd(2, .@"enum"),
        };

        pub fn encode(
            self: @This(),
            writer: std.io.AnyWriter,
            allocator: std.mem.Allocator,
        ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        pub fn decode(
            input: []const u8,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), input, allocator);
        }

        pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.init(@This(), allocator);
        }

        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        pub fn jsonEncode(
            self: @This(),
            options: std.json.StringifyOptions,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        // This method is used by std.json
        // internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        // This method is used by std.json
        // internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    pub fn encode(
        self: @This(),
        writer: std.io.AnyWriter,
        allocator: std.mem.Allocator,
    ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        input: []const u8,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), input, allocator);
    }

    pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.init(@This(), allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.StringifyOptions,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const ForeignMessage = struct {
    c: i32 = 0,

    pub const _desc_table = .{
        .c = fd(1, .{ .scalar = .int32 }),
    };

    pub fn encode(
        self: @This(),
        writer: std.io.AnyWriter,
        allocator: std.mem.Allocator,
    ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        input: []const u8,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), input, allocator);
    }

    pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.init(@This(), allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.StringifyOptions,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const NullHypothesisProto3 = struct {
    pub const _desc_table = .{};

    pub fn encode(
        self: @This(),
        writer: std.io.AnyWriter,
        allocator: std.mem.Allocator,
    ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        input: []const u8,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), input, allocator);
    }

    pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.init(@This(), allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.StringifyOptions,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const EnumOnlyProto3 = struct {
    pub const _desc_table = .{};

    pub const Bool = enum(i32) {
        kFalse = 0,
        kTrue = 1,
        _,
    };

    pub fn encode(
        self: @This(),
        writer: std.io.AnyWriter,
        allocator: std.mem.Allocator,
    ) (std.io.AnyWriter.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    pub fn decode(
        input: []const u8,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.io.AnyReader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), input, allocator);
    }

    pub fn init(allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.init(@This(), allocator);
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    pub fn jsonEncode(
        self: @This(),
        options: std.json.StringifyOptions,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    // This method is used by std.json
    // internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    // This method is used by std.json
    // internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};
