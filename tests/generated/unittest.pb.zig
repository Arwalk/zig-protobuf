// Code generated by protoc-gen-zig
///! package unittest
const std = @import("std");

const protobuf = @import("protobuf");
const fd = protobuf.fd;

pub const ForeignEnum = enum(i32) {
    FOREIGN_FOO = 4,
    FOREIGN_BAR = 5,
    FOREIGN_BAZ = 6,
    _,
};

pub const TestReservedEnumFields = enum(i32) {
    UNKNOWN = 0,
    _,
};

/// Test an enum that has multiple values with the same number.
pub const TestEnumWithDupValue = enum(i32) {
    FOO1 = 1,
    BAR1 = 2,
    BAZ = 3,
    FOO2 = 1,
    BAR2 = 2,
    _,
};

/// Test an enum with large, unordered values.
pub const TestSparseEnum = enum(i32) {
    SPARSE_A = 123,
    SPARSE_B = 62374,
    SPARSE_C = 12589234,
    SPARSE_D = -15,
    SPARSE_E = -53452,
    SPARSE_F = 0,
    SPARSE_G = 2,
    _,
};

pub const VeryLargeEnum = enum(i32) {
    ENUM_LABEL_DEFAULT = 0,
    ENUM_LABEL_1 = 1,
    ENUM_LABEL_2 = 2,
    ENUM_LABEL_3 = 3,
    ENUM_LABEL_4 = 4,
    ENUM_LABEL_5 = 5,
    ENUM_LABEL_6 = 6,
    ENUM_LABEL_7 = 7,
    ENUM_LABEL_8 = 8,
    ENUM_LABEL_9 = 9,
    ENUM_LABEL_10 = 10,
    ENUM_LABEL_11 = 11,
    ENUM_LABEL_12 = 12,
    ENUM_LABEL_13 = 13,
    ENUM_LABEL_14 = 14,
    ENUM_LABEL_15 = 15,
    ENUM_LABEL_16 = 16,
    ENUM_LABEL_17 = 17,
    ENUM_LABEL_18 = 18,
    ENUM_LABEL_19 = 19,
    ENUM_LABEL_20 = 20,
    ENUM_LABEL_21 = 21,
    ENUM_LABEL_22 = 22,
    ENUM_LABEL_23 = 23,
    ENUM_LABEL_24 = 24,
    ENUM_LABEL_25 = 25,
    ENUM_LABEL_26 = 26,
    ENUM_LABEL_27 = 27,
    ENUM_LABEL_28 = 28,
    ENUM_LABEL_29 = 29,
    ENUM_LABEL_30 = 30,
    ENUM_LABEL_31 = 31,
    ENUM_LABEL_32 = 32,
    ENUM_LABEL_33 = 33,
    ENUM_LABEL_34 = 34,
    ENUM_LABEL_35 = 35,
    ENUM_LABEL_36 = 36,
    ENUM_LABEL_37 = 37,
    ENUM_LABEL_38 = 38,
    ENUM_LABEL_39 = 39,
    ENUM_LABEL_40 = 40,
    ENUM_LABEL_41 = 41,
    ENUM_LABEL_42 = 42,
    ENUM_LABEL_43 = 43,
    ENUM_LABEL_44 = 44,
    ENUM_LABEL_45 = 45,
    ENUM_LABEL_46 = 46,
    ENUM_LABEL_47 = 47,
    ENUM_LABEL_48 = 48,
    ENUM_LABEL_49 = 49,
    ENUM_LABEL_50 = 50,
    ENUM_LABEL_51 = 51,
    ENUM_LABEL_52 = 52,
    ENUM_LABEL_53 = 53,
    ENUM_LABEL_54 = 54,
    ENUM_LABEL_55 = 55,
    ENUM_LABEL_56 = 56,
    ENUM_LABEL_57 = 57,
    ENUM_LABEL_58 = 58,
    ENUM_LABEL_59 = 59,
    ENUM_LABEL_60 = 60,
    ENUM_LABEL_61 = 61,
    ENUM_LABEL_62 = 62,
    ENUM_LABEL_63 = 63,
    ENUM_LABEL_64 = 64,
    ENUM_LABEL_65 = 65,
    ENUM_LABEL_66 = 66,
    ENUM_LABEL_67 = 67,
    ENUM_LABEL_68 = 68,
    ENUM_LABEL_69 = 69,
    ENUM_LABEL_70 = 70,
    ENUM_LABEL_71 = 71,
    ENUM_LABEL_72 = 72,
    ENUM_LABEL_73 = 73,
    ENUM_LABEL_74 = 74,
    ENUM_LABEL_75 = 75,
    ENUM_LABEL_76 = 76,
    ENUM_LABEL_77 = 77,
    ENUM_LABEL_78 = 78,
    ENUM_LABEL_79 = 79,
    ENUM_LABEL_80 = 80,
    ENUM_LABEL_81 = 81,
    ENUM_LABEL_82 = 82,
    ENUM_LABEL_83 = 83,
    ENUM_LABEL_84 = 84,
    ENUM_LABEL_85 = 85,
    ENUM_LABEL_86 = 86,
    ENUM_LABEL_87 = 87,
    ENUM_LABEL_88 = 88,
    ENUM_LABEL_89 = 89,
    ENUM_LABEL_90 = 90,
    ENUM_LABEL_91 = 91,
    ENUM_LABEL_92 = 92,
    ENUM_LABEL_93 = 93,
    ENUM_LABEL_94 = 94,
    ENUM_LABEL_95 = 95,
    ENUM_LABEL_96 = 96,
    ENUM_LABEL_97 = 97,
    ENUM_LABEL_98 = 98,
    ENUM_LABEL_99 = 99,
    ENUM_LABEL_100 = 100,
    _,
};

/// This proto includes every type of field in both singular and repeated
/// forms.
pub const TestAllTypes = struct {
    optional_int32: ?i32 = null,
    optional_int64: ?i64 = null,
    optional_uint32: ?u32 = null,
    optional_uint64: ?u64 = null,
    optional_sint32: ?i32 = null,
    optional_sint64: ?i64 = null,
    optional_fixed32: ?u32 = null,
    optional_fixed64: ?u64 = null,
    optional_sfixed32: ?i32 = null,
    optional_sfixed64: ?i64 = null,
    optional_float: ?f32 = null,
    optional_double: ?f64 = null,
    optional_bool: ?bool = null,
    optional_string: ?[]const u8 = null,
    optional_bytes: ?[]const u8 = null,
    a: ?i32 = null,
    optional_nested_message: ?TestAllTypes.NestedMessage = null,
    optional_foreign_message: ?ForeignMessage = null,
    optional_nested_enum: ?TestAllTypes.NestedEnum = null,
    optional_foreign_enum: ?ForeignEnum = null,
    optional_string_piece: ?[]const u8 = null,
    optional_cord: ?[]const u8 = null,
    optional_lazy_message: ?TestAllTypes.NestedMessage = null,
    repeated_int32: std.ArrayListUnmanaged(i32) = .empty,
    repeated_int64: std.ArrayListUnmanaged(i64) = .empty,
    repeated_uint32: std.ArrayListUnmanaged(u32) = .empty,
    repeated_uint64: std.ArrayListUnmanaged(u64) = .empty,
    repeated_sint32: std.ArrayListUnmanaged(i32) = .empty,
    repeated_sint64: std.ArrayListUnmanaged(i64) = .empty,
    repeated_fixed32: std.ArrayListUnmanaged(u32) = .empty,
    repeated_fixed64: std.ArrayListUnmanaged(u64) = .empty,
    repeated_sfixed32: std.ArrayListUnmanaged(i32) = .empty,
    repeated_sfixed64: std.ArrayListUnmanaged(i64) = .empty,
    repeated_float: std.ArrayListUnmanaged(f32) = .empty,
    repeated_double: std.ArrayListUnmanaged(f64) = .empty,
    repeated_bool: std.ArrayListUnmanaged(bool) = .empty,
    repeated_string: std.ArrayListUnmanaged([]const u8) = .empty,
    repeated_bytes: std.ArrayListUnmanaged([]const u8) = .empty,
    RepeatedGroup_a: std.ArrayListUnmanaged(i32) = .empty,
    repeated_nested_message: std.ArrayListUnmanaged(TestAllTypes.NestedMessage) = .empty,
    repeated_foreign_message: std.ArrayListUnmanaged(ForeignMessage) = .empty,
    repeated_nested_enum: std.ArrayListUnmanaged(TestAllTypes.NestedEnum) = .empty,
    repeated_foreign_enum: std.ArrayListUnmanaged(ForeignEnum) = .empty,
    repeated_string_piece: std.ArrayListUnmanaged([]const u8) = .empty,
    repeated_cord: std.ArrayListUnmanaged([]const u8) = .empty,
    repeated_lazy_message: std.ArrayListUnmanaged(TestAllTypes.NestedMessage) = .empty,
    default_int32: ?i32 = 41,
    default_int64: ?i64 = 42,
    default_uint32: ?u32 = 43,
    default_uint64: ?u64 = 44,
    default_sint32: ?i32 = -45,
    default_sint64: ?i64 = 46,
    default_fixed32: ?u32 = 47,
    default_fixed64: ?u64 = 48,
    default_sfixed32: ?i32 = 49,
    default_sfixed64: ?i64 = -50,
    default_float: ?f32 = 51.5,
    default_double: ?f64 = 52000,
    default_bool: ?bool = true,
    default_string: ?[]const u8 = "hello",
    default_bytes: ?[]const u8 = "world",
    default_nested_enum: ?TestAllTypes.NestedEnum = .BAR,
    default_foreign_enum: ?ForeignEnum = .FOREIGN_BAR,
    default_string_piece: ?[]const u8 = "abc",
    default_cord: ?[]const u8 = "123",
    oneof_field: ?oneof_field_union = null,

    pub const _oneof_field_case = enum {
        oneof_uint32,
        oneof_nested_message,
        oneof_string,
        oneof_bytes,
    };
    pub const oneof_field_union = union(_oneof_field_case) {
        oneof_uint32: u32,
        oneof_nested_message: TestAllTypes.NestedMessage,
        oneof_string: []const u8,
        oneof_bytes: []const u8,
        pub const _desc_table = .{
            .oneof_uint32 = fd(111, .{ .scalar = .uint32 }),
            .oneof_nested_message = fd(112, .submessage),
            .oneof_string = fd(113, .{ .scalar = .string }),
            .oneof_bytes = fd(114, .{ .scalar = .bytes }),
        };
    };

    pub const _desc_table = .{
        .optional_int32 = fd(1, .{ .scalar = .int32 }),
        .optional_int64 = fd(2, .{ .scalar = .int64 }),
        .optional_uint32 = fd(3, .{ .scalar = .uint32 }),
        .optional_uint64 = fd(4, .{ .scalar = .uint64 }),
        .optional_sint32 = fd(5, .{ .scalar = .sint32 }),
        .optional_sint64 = fd(6, .{ .scalar = .sint64 }),
        .optional_fixed32 = fd(7, .{ .scalar = .fixed32 }),
        .optional_fixed64 = fd(8, .{ .scalar = .fixed64 }),
        .optional_sfixed32 = fd(9, .{ .scalar = .sfixed32 }),
        .optional_sfixed64 = fd(10, .{ .scalar = .sfixed64 }),
        .optional_float = fd(11, .{ .scalar = .float }),
        .optional_double = fd(12, .{ .scalar = .double }),
        .optional_bool = fd(13, .{ .scalar = .bool }),
        .optional_string = fd(14, .{ .scalar = .string }),
        .optional_bytes = fd(15, .{ .scalar = .bytes }),
        .a = fd(17, .{ .scalar = .int32 }),
        .optional_nested_message = fd(18, .submessage),
        .optional_foreign_message = fd(19, .submessage),
        .optional_nested_enum = fd(21, .@"enum"),
        .optional_foreign_enum = fd(22, .@"enum"),
        .optional_string_piece = fd(24, .{ .scalar = .string }),
        .optional_cord = fd(25, .{ .scalar = .string }),
        .optional_lazy_message = fd(27, .submessage),
        .repeated_int32 = fd(31, .{ .repeated = .{ .scalar = .int32 } }),
        .repeated_int64 = fd(32, .{ .repeated = .{ .scalar = .int64 } }),
        .repeated_uint32 = fd(33, .{ .repeated = .{ .scalar = .uint32 } }),
        .repeated_uint64 = fd(34, .{ .repeated = .{ .scalar = .uint64 } }),
        .repeated_sint32 = fd(35, .{ .repeated = .{ .scalar = .sint32 } }),
        .repeated_sint64 = fd(36, .{ .repeated = .{ .scalar = .sint64 } }),
        .repeated_fixed32 = fd(37, .{ .repeated = .{ .scalar = .fixed32 } }),
        .repeated_fixed64 = fd(38, .{ .repeated = .{ .scalar = .fixed64 } }),
        .repeated_sfixed32 = fd(39, .{ .repeated = .{ .scalar = .sfixed32 } }),
        .repeated_sfixed64 = fd(40, .{ .repeated = .{ .scalar = .sfixed64 } }),
        .repeated_float = fd(41, .{ .repeated = .{ .scalar = .float } }),
        .repeated_double = fd(42, .{ .repeated = .{ .scalar = .double } }),
        .repeated_bool = fd(43, .{ .repeated = .{ .scalar = .bool } }),
        .repeated_string = fd(44, .{ .repeated = .{ .scalar = .string } }),
        .repeated_bytes = fd(45, .{ .repeated = .{ .scalar = .bytes } }),
        .RepeatedGroup_a = fd(47, .{ .repeated = .{ .scalar = .int32 } }),
        .repeated_nested_message = fd(48, .{ .repeated = .submessage }),
        .repeated_foreign_message = fd(49, .{ .repeated = .submessage }),
        .repeated_nested_enum = fd(51, .{ .repeated = .@"enum" }),
        .repeated_foreign_enum = fd(52, .{ .repeated = .@"enum" }),
        .repeated_string_piece = fd(54, .{ .repeated = .{ .scalar = .string } }),
        .repeated_cord = fd(55, .{ .repeated = .{ .scalar = .string } }),
        .repeated_lazy_message = fd(57, .{ .repeated = .submessage }),
        .default_int32 = fd(61, .{ .scalar = .int32 }),
        .default_int64 = fd(62, .{ .scalar = .int64 }),
        .default_uint32 = fd(63, .{ .scalar = .uint32 }),
        .default_uint64 = fd(64, .{ .scalar = .uint64 }),
        .default_sint32 = fd(65, .{ .scalar = .sint32 }),
        .default_sint64 = fd(66, .{ .scalar = .sint64 }),
        .default_fixed32 = fd(67, .{ .scalar = .fixed32 }),
        .default_fixed64 = fd(68, .{ .scalar = .fixed64 }),
        .default_sfixed32 = fd(69, .{ .scalar = .sfixed32 }),
        .default_sfixed64 = fd(70, .{ .scalar = .sfixed64 }),
        .default_float = fd(71, .{ .scalar = .float }),
        .default_double = fd(72, .{ .scalar = .double }),
        .default_bool = fd(73, .{ .scalar = .bool }),
        .default_string = fd(74, .{ .scalar = .string }),
        .default_bytes = fd(75, .{ .scalar = .bytes }),
        .default_nested_enum = fd(81, .@"enum"),
        .default_foreign_enum = fd(82, .@"enum"),
        .default_string_piece = fd(84, .{ .scalar = .string }),
        .default_cord = fd(85, .{ .scalar = .string }),
        .oneof_field = fd(null, .{ .oneof = oneof_field_union }),
    };

    pub const NestedEnum = enum(i32) {
        FOO = 1,
        BAR = 2,
        BAZ = 3,
        NEG = -1,
        _,
    };

    pub const NestedMessage = struct {
        bb: ?i32 = null,

        pub const _desc_table = .{
            .bb = fd(1, .{ .scalar = .int32 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// This proto includes a recursively nested message.
pub const NestedTestAllTypes = struct {
    child: ?*NestedTestAllTypes = null,
    payload: ?TestAllTypes = null,
    repeated_child: std.ArrayListUnmanaged(NestedTestAllTypes) = .empty,
    lazy_child: ?*NestedTestAllTypes = null,
    eager_child: ?TestAllTypes = null,

    pub const _desc_table = .{
        .child = fd(1, .submessage),
        .payload = fd(2, .submessage),
        .repeated_child = fd(3, .{ .repeated = .submessage }),
        .lazy_child = fd(4, .submessage),
        .eager_child = fd(5, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestDeprecatedFields = struct {
    deprecated_int32: ?i32 = null,
    deprecated_int32_in_oneof: ?i32 = null,

    pub const _desc_table = .{
        .deprecated_int32 = fd(1, .{ .scalar = .int32 }),
        .deprecated_int32_in_oneof = fd(2, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestDeprecatedMessage = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Define these after TestAllTypes to make sure the compiler can handle
/// that.
pub const ForeignMessage = struct {
    c: ?i32 = null,
    d: ?i32 = null,

    pub const _desc_table = .{
        .c = fd(1, .{ .scalar = .int32 }),
        .d = fd(2, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestReservedFields = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestAllExtensions = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestGroup = struct {
    a: ?i32 = null,
    optional_foreign_enum: ?ForeignEnum = null,

    pub const _desc_table = .{
        .a = fd(17, .{ .scalar = .int32 }),
        .optional_foreign_enum = fd(22, .@"enum"),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestGroupExtension = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestNestedExtension = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestChildExtension = struct {
    a: ?[]const u8 = null,
    b: ?[]const u8 = null,
    optional_extension: ?TestAllExtensions = null,

    pub const _desc_table = .{
        .a = fd(1, .{ .scalar = .string }),
        .b = fd(2, .{ .scalar = .string }),
        .optional_extension = fd(3, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Emulates wireformat data of TestChildExtension with dynamic extension
/// (DynamicExtension).
pub const TestChildExtensionData = struct {
    a: ?[]const u8 = null,
    b: ?[]const u8 = null,
    optional_extension: ?TestChildExtensionData.NestedTestAllExtensionsData = null,

    pub const _desc_table = .{
        .a = fd(1, .{ .scalar = .string }),
        .b = fd(2, .{ .scalar = .string }),
        .optional_extension = fd(3, .submessage),
    };

    pub const NestedTestAllExtensionsData = struct {
        dynamic: ?TestChildExtensionData.NestedTestAllExtensionsData.NestedDynamicExtensions = null,

        pub const _desc_table = .{
            .dynamic = fd(409707008, .submessage),
        };

        pub const NestedDynamicExtensions = struct {
            a: ?i32 = null,
            b: ?i32 = null,

            pub const _desc_table = .{
                .a = fd(1, .{ .scalar = .int32 }),
                .b = fd(2, .{ .scalar = .int32 }),
            };

            /// Encodes the message to the writer
            /// The allocator is used to generate submessages internally.
            /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
            pub fn encode(
                self: @This(),
                writer: *std.Io.Writer,
                allocator: std.mem.Allocator,
            ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
                return protobuf.encode(writer, allocator, self);
            }

            /// Decodes the message from the bytes read from the reader.
            pub fn decode(
                reader: *std.Io.Reader,
                allocator: std.mem.Allocator,
            ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
                return protobuf.decode(@This(), reader, allocator);
            }

            /// Deinitializes and frees the memory associated with the message.
            pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
                return protobuf.deinit(allocator, self);
            }

            /// Duplicates the message.
            pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
                return protobuf.dupe(@This(), self, allocator);
            }

            /// Decodes the message from the JSON string.
            pub fn jsonDecode(
                input: []const u8,
                options: std.json.ParseOptions,
                allocator: std.mem.Allocator,
            ) !std.json.Parsed(@This()) {
                return protobuf.json.decode(@This(), input, options, allocator);
            }

            /// Encodes the message to a JSON string.
            pub fn jsonEncode(
                self: @This(),
                options: std.json.Stringify.Options,
                allocator: std.mem.Allocator,
            ) ![]const u8 {
                return protobuf.json.encode(self, options, allocator);
            }

            /// This method is used by std.json
            /// internally for deserialization. DO NOT RENAME!
            pub fn jsonParse(
                allocator: std.mem.Allocator,
                source: anytype,
                options: std.json.ParseOptions,
            ) !@This() {
                return protobuf.json.parse(@This(), allocator, source, options);
            }

            /// This method is used by std.json
            /// internally for serialization. DO NOT RENAME!
            pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                return protobuf.json.stringify(@This(), self, jws);
            }
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestNestedChildExtension = struct {
    a: ?i32 = null,
    child: ?TestChildExtension = null,

    pub const _desc_table = .{
        .a = fd(1, .{ .scalar = .int32 }),
        .child = fd(2, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Emulates wireformat data of TestNestedChildExtension with dynamic extension
/// (DynamicExtension).
pub const TestNestedChildExtensionData = struct {
    a: ?i32 = null,
    child: ?TestChildExtensionData = null,

    pub const _desc_table = .{
        .a = fd(1, .{ .scalar = .int32 }),
        .child = fd(2, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// We have separate messages for testing required fields because it's
/// annoying to have to fill in required fields in TestProto in order to
/// do anything with it.  Note that we don't need to test every type of
/// required filed because the code output is basically identical to
/// optional fields for all types.
pub const TestRequired = struct {
    a: i32,
    dummy2: ?i32 = null,
    b: i32,
    dummy4: ?i32 = null,
    dummy5: ?i32 = null,
    dummy6: ?i32 = null,
    dummy7: ?i32 = null,
    dummy8: ?i32 = null,
    dummy9: ?i32 = null,
    dummy10: ?i32 = null,
    dummy11: ?i32 = null,
    dummy12: ?i32 = null,
    dummy13: ?i32 = null,
    dummy14: ?i32 = null,
    dummy15: ?i32 = null,
    dummy16: ?i32 = null,
    dummy17: ?i32 = null,
    dummy18: ?i32 = null,
    dummy19: ?i32 = null,
    dummy20: ?i32 = null,
    dummy21: ?i32 = null,
    dummy22: ?i32 = null,
    dummy23: ?i32 = null,
    dummy24: ?i32 = null,
    dummy25: ?i32 = null,
    dummy26: ?i32 = null,
    dummy27: ?i32 = null,
    dummy28: ?i32 = null,
    dummy29: ?i32 = null,
    dummy30: ?i32 = null,
    dummy31: ?i32 = null,
    dummy32: ?i32 = null,
    c: i32,
    optional_foreign: ?ForeignMessage = null,

    pub const _desc_table = .{
        .a = fd(1, .{ .scalar = .int32 }),
        .dummy2 = fd(2, .{ .scalar = .int32 }),
        .b = fd(3, .{ .scalar = .int32 }),
        .dummy4 = fd(4, .{ .scalar = .int32 }),
        .dummy5 = fd(5, .{ .scalar = .int32 }),
        .dummy6 = fd(6, .{ .scalar = .int32 }),
        .dummy7 = fd(7, .{ .scalar = .int32 }),
        .dummy8 = fd(8, .{ .scalar = .int32 }),
        .dummy9 = fd(9, .{ .scalar = .int32 }),
        .dummy10 = fd(10, .{ .scalar = .int32 }),
        .dummy11 = fd(11, .{ .scalar = .int32 }),
        .dummy12 = fd(12, .{ .scalar = .int32 }),
        .dummy13 = fd(13, .{ .scalar = .int32 }),
        .dummy14 = fd(14, .{ .scalar = .int32 }),
        .dummy15 = fd(15, .{ .scalar = .int32 }),
        .dummy16 = fd(16, .{ .scalar = .int32 }),
        .dummy17 = fd(17, .{ .scalar = .int32 }),
        .dummy18 = fd(18, .{ .scalar = .int32 }),
        .dummy19 = fd(19, .{ .scalar = .int32 }),
        .dummy20 = fd(20, .{ .scalar = .int32 }),
        .dummy21 = fd(21, .{ .scalar = .int32 }),
        .dummy22 = fd(22, .{ .scalar = .int32 }),
        .dummy23 = fd(23, .{ .scalar = .int32 }),
        .dummy24 = fd(24, .{ .scalar = .int32 }),
        .dummy25 = fd(25, .{ .scalar = .int32 }),
        .dummy26 = fd(26, .{ .scalar = .int32 }),
        .dummy27 = fd(27, .{ .scalar = .int32 }),
        .dummy28 = fd(28, .{ .scalar = .int32 }),
        .dummy29 = fd(29, .{ .scalar = .int32 }),
        .dummy30 = fd(30, .{ .scalar = .int32 }),
        .dummy31 = fd(31, .{ .scalar = .int32 }),
        .dummy32 = fd(32, .{ .scalar = .int32 }),
        .c = fd(33, .{ .scalar = .int32 }),
        .optional_foreign = fd(34, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestRequiredForeign = struct {
    optional_message: ?TestRequired = null,
    repeated_message: std.ArrayListUnmanaged(TestRequired) = .empty,
    dummy: ?i32 = null,
    optional_lazy_message: ?NestedTestAllTypes = null,

    pub const _desc_table = .{
        .optional_message = fd(1, .submessage),
        .repeated_message = fd(2, .{ .repeated = .submessage }),
        .dummy = fd(3, .{ .scalar = .int32 }),
        .optional_lazy_message = fd(4, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestRequiredMessage = struct {
    optional_message: ?TestRequired = null,
    repeated_message: std.ArrayListUnmanaged(TestRequired) = .empty,
    required_message: ?TestRequired = null,

    pub const _desc_table = .{
        .optional_message = fd(1, .submessage),
        .repeated_message = fd(2, .{ .repeated = .submessage }),
        .required_message = fd(3, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestNestedRequiredForeign = struct {
    child: ?*TestNestedRequiredForeign = null,
    payload: ?TestRequiredForeign = null,
    dummy: ?i32 = null,

    pub const _desc_table = .{
        .child = fd(1, .submessage),
        .payload = fd(2, .submessage),
        .dummy = fd(3, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Test that we can use NestedMessage from outside TestAllTypes.
pub const TestForeignNested = struct {
    foreign_nested: ?TestAllTypes.NestedMessage = null,

    pub const _desc_table = .{
        .foreign_nested = fd(1, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// TestEmptyMessage is used to test unknown field support.
pub const TestEmptyMessage = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Like above, but declare all field numbers as potential extensions.  No
/// actual extensions should ever be defined for this type.
pub const TestEmptyMessageWithExtensions = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Needed for a Python test.
pub const TestPickleNestedMessage = struct {
    pub const _desc_table = .{};

    pub const NestedMessage = struct {
        bb: ?i32 = null,

        pub const _desc_table = .{
            .bb = fd(1, .{ .scalar = .int32 }),
        };

        pub const NestedNestedMessage = struct {
            cc: ?i32 = null,

            pub const _desc_table = .{
                .cc = fd(1, .{ .scalar = .int32 }),
            };

            /// Encodes the message to the writer
            /// The allocator is used to generate submessages internally.
            /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
            pub fn encode(
                self: @This(),
                writer: *std.Io.Writer,
                allocator: std.mem.Allocator,
            ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
                return protobuf.encode(writer, allocator, self);
            }

            /// Decodes the message from the bytes read from the reader.
            pub fn decode(
                reader: *std.Io.Reader,
                allocator: std.mem.Allocator,
            ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
                return protobuf.decode(@This(), reader, allocator);
            }

            /// Deinitializes and frees the memory associated with the message.
            pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
                return protobuf.deinit(allocator, self);
            }

            /// Duplicates the message.
            pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
                return protobuf.dupe(@This(), self, allocator);
            }

            /// Decodes the message from the JSON string.
            pub fn jsonDecode(
                input: []const u8,
                options: std.json.ParseOptions,
                allocator: std.mem.Allocator,
            ) !std.json.Parsed(@This()) {
                return protobuf.json.decode(@This(), input, options, allocator);
            }

            /// Encodes the message to a JSON string.
            pub fn jsonEncode(
                self: @This(),
                options: std.json.Stringify.Options,
                allocator: std.mem.Allocator,
            ) ![]const u8 {
                return protobuf.json.encode(self, options, allocator);
            }

            /// This method is used by std.json
            /// internally for deserialization. DO NOT RENAME!
            pub fn jsonParse(
                allocator: std.mem.Allocator,
                source: anytype,
                options: std.json.ParseOptions,
            ) !@This() {
                return protobuf.json.parse(@This(), allocator, source, options);
            }

            /// This method is used by std.json
            /// internally for serialization. DO NOT RENAME!
            pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
                return protobuf.json.stringify(@This(), self, jws);
            }
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestMultipleExtensionRanges = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Test that really large tag numbers don't break anything.
pub const TestReallyLargeTagNumber = struct {
    a: ?i32 = null,
    bb: ?i32 = null,

    pub const _desc_table = .{
        .a = fd(1, .{ .scalar = .int32 }),
        .bb = fd(268435455, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestRecursiveMessage = struct {
    a: ?*TestRecursiveMessage = null,
    i: ?i32 = null,

    pub const _desc_table = .{
        .a = fd(1, .submessage),
        .i = fd(2, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Test that mutual recursion works.
pub const TestMutualRecursionA = struct {
    bb: ?TestMutualRecursionB = null,
    sub_message: ?TestMutualRecursionA.SubMessage = null,
    not_in_this_scc: ?TestAllTypes = null,

    pub const _desc_table = .{
        .bb = fd(1, .submessage),
        .sub_message = fd(3, .submessage),
        .not_in_this_scc = fd(4, .submessage),
    };

    pub const SubMessage = struct {
        b: ?TestMutualRecursionB = null,

        pub const _desc_table = .{
            .b = fd(1, .submessage),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestMutualRecursionB = struct {
    a: ?TestMutualRecursionA = null,
    optional_int32: ?i32 = null,

    pub const _desc_table = .{
        .a = fd(1, .submessage),
        .optional_int32 = fd(2, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestIsInitialized = struct {
    sub_message: ?TestIsInitialized.SubMessage = null,

    pub const _desc_table = .{
        .sub_message = fd(1, .submessage),
    };

    pub const SubMessage = struct {
        i: i32,

        pub const _desc_table = .{
            .i = fd(2, .{ .scalar = .int32 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Test that groups have disjoint field numbers from their siblings and
/// parents.  This is NOT possible in proto1; only google.protobuf.  When
/// attempting to compile with proto1, this will emit an error; so we only
/// include it in protobuf_unittest_proto.
pub const TestDupFieldNumber = struct {
    a: ?i32 = null,

    pub const _desc_table = .{
        .a = fd(1, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Additional messages for testing lazy fields.
pub const TestEagerMessage = struct {
    sub_message: ?TestAllTypes = null,

    pub const _desc_table = .{
        .sub_message = fd(1, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestLazyMessage = struct {
    sub_message: ?TestAllTypes = null,

    pub const _desc_table = .{
        .sub_message = fd(1, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestEagerMaybeLazy = struct {
    message_foo: ?TestAllTypes = null,
    message_bar: ?TestAllTypes = null,
    message_baz: ?TestEagerMaybeLazy.NestedMessage = null,

    pub const _desc_table = .{
        .message_foo = fd(1, .submessage),
        .message_bar = fd(2, .submessage),
        .message_baz = fd(3, .submessage),
    };

    pub const NestedMessage = struct {
        @"packed": ?TestPackedTypes = null,

        pub const _desc_table = .{
            .@"packed" = fd(1, .submessage),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Needed for a Python test.
pub const TestNestedMessageHasBits = struct {
    optional_nested_message: ?TestNestedMessageHasBits.NestedMessage = null,

    pub const _desc_table = .{
        .optional_nested_message = fd(1, .submessage),
    };

    pub const NestedMessage = struct {
        nestedmessage_repeated_int32: std.ArrayListUnmanaged(i32) = .empty,
        nestedmessage_repeated_foreignmessage: std.ArrayListUnmanaged(ForeignMessage) = .empty,

        pub const _desc_table = .{
            .nestedmessage_repeated_int32 = fd(1, .{ .repeated = .{ .scalar = .int32 } }),
            .nestedmessage_repeated_foreignmessage = fd(2, .{ .repeated = .submessage }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Test message with CamelCase field names.  This violates Protocol Buffer
/// standard style.
pub const TestCamelCaseFieldNames = struct {
    PrimitiveField: ?i32 = null,
    StringField: ?[]const u8 = null,
    EnumField: ?ForeignEnum = null,
    MessageField: ?ForeignMessage = null,
    StringPieceField: ?[]const u8 = null,
    CordField: ?[]const u8 = null,
    RepeatedPrimitiveField: std.ArrayListUnmanaged(i32) = .empty,
    RepeatedStringField: std.ArrayListUnmanaged([]const u8) = .empty,
    RepeatedEnumField: std.ArrayListUnmanaged(ForeignEnum) = .empty,
    RepeatedMessageField: std.ArrayListUnmanaged(ForeignMessage) = .empty,
    RepeatedStringPieceField: std.ArrayListUnmanaged([]const u8) = .empty,
    RepeatedCordField: std.ArrayListUnmanaged([]const u8) = .empty,

    pub const _desc_table = .{
        .PrimitiveField = fd(1, .{ .scalar = .int32 }),
        .StringField = fd(2, .{ .scalar = .string }),
        .EnumField = fd(3, .@"enum"),
        .MessageField = fd(4, .submessage),
        .StringPieceField = fd(5, .{ .scalar = .string }),
        .CordField = fd(6, .{ .scalar = .string }),
        .RepeatedPrimitiveField = fd(7, .{ .repeated = .{ .scalar = .int32 } }),
        .RepeatedStringField = fd(8, .{ .repeated = .{ .scalar = .string } }),
        .RepeatedEnumField = fd(9, .{ .repeated = .@"enum" }),
        .RepeatedMessageField = fd(10, .{ .repeated = .submessage }),
        .RepeatedStringPieceField = fd(11, .{ .repeated = .{ .scalar = .string } }),
        .RepeatedCordField = fd(12, .{ .repeated = .{ .scalar = .string } }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// We list fields out of order, to ensure that we're using field number and not
/// field index to determine serialization order.
pub const TestFieldOrderings = struct {
    my_string: ?[]const u8 = null,
    my_int: ?i64 = null,
    my_float: ?f32 = null,
    optional_nested_message: ?TestFieldOrderings.NestedMessage = null,

    pub const _desc_table = .{
        .my_string = fd(11, .{ .scalar = .string }),
        .my_int = fd(1, .{ .scalar = .int64 }),
        .my_float = fd(101, .{ .scalar = .float }),
        .optional_nested_message = fd(200, .submessage),
    };

    pub const NestedMessage = struct {
        oo: ?i64 = null,
        bb: ?i32 = null,

        pub const _desc_table = .{
            .oo = fd(2, .{ .scalar = .int64 }),
            .bb = fd(1, .{ .scalar = .int32 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestExtensionOrderings1 = struct {
    my_string: ?[]const u8 = null,

    pub const _desc_table = .{
        .my_string = fd(1, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestExtensionOrderings2 = struct {
    my_string: ?[]const u8 = null,

    pub const _desc_table = .{
        .my_string = fd(1, .{ .scalar = .string }),
    };

    pub const TestExtensionOrderings3 = struct {
        my_string: ?[]const u8 = null,

        pub const _desc_table = .{
            .my_string = fd(1, .{ .scalar = .string }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestExtremeDefaultValues = struct {
    escaped_bytes: ?[]const u8 = "\\000\\001\\007\\010\\014\\n\\r\\t\\013\\\\\\'\\\"\\376",
    large_uint32: ?u32 = 4294967295,
    large_uint64: ?u64 = 18446744073709551615,
    small_int32: ?i32 = -2147483647,
    small_int64: ?i64 = -9223372036854775807,
    really_small_int32: ?i32 = -2147483648,
    really_small_int64: ?i64 = -9223372036854775808,
    utf8_string: ?[]const u8 = "\xe1\x88\xb4",
    zero_float: ?f32 = 0,
    one_float: ?f32 = 1,
    small_float: ?f32 = 1.5,
    negative_one_float: ?f32 = -1,
    negative_float: ?f32 = -1.5,
    large_float: ?f32 = 2e+08,
    small_negative_float: ?f32 = -8e-28,
    inf_double: ?f64 = std.math.inf(f64),
    neg_inf_double: ?f64 = -std.math.inf(f64),
    nan_double: ?f64 = std.math.nan(f64),
    inf_float: ?f32 = std.math.inf(f32),
    neg_inf_float: ?f32 = -std.math.inf(f32),
    nan_float: ?f32 = std.math.nan(f32),
    cpp_trigraph: ?[]const u8 = "? ? ?? ?? ??? ??/ ??-",
    string_with_zero: ?[]const u8 = "hel\x00lo",
    bytes_with_zero: ?[]const u8 = "wor\\000ld",
    string_piece_with_zero: ?[]const u8 = "ab\x00c",
    cord_with_zero: ?[]const u8 = "12\x003",
    replacement_string: ?[]const u8 = "${unknown}",

    pub const _desc_table = .{
        .escaped_bytes = fd(1, .{ .scalar = .bytes }),
        .large_uint32 = fd(2, .{ .scalar = .uint32 }),
        .large_uint64 = fd(3, .{ .scalar = .uint64 }),
        .small_int32 = fd(4, .{ .scalar = .int32 }),
        .small_int64 = fd(5, .{ .scalar = .int64 }),
        .really_small_int32 = fd(21, .{ .scalar = .int32 }),
        .really_small_int64 = fd(22, .{ .scalar = .int64 }),
        .utf8_string = fd(6, .{ .scalar = .string }),
        .zero_float = fd(7, .{ .scalar = .float }),
        .one_float = fd(8, .{ .scalar = .float }),
        .small_float = fd(9, .{ .scalar = .float }),
        .negative_one_float = fd(10, .{ .scalar = .float }),
        .negative_float = fd(11, .{ .scalar = .float }),
        .large_float = fd(12, .{ .scalar = .float }),
        .small_negative_float = fd(13, .{ .scalar = .float }),
        .inf_double = fd(14, .{ .scalar = .double }),
        .neg_inf_double = fd(15, .{ .scalar = .double }),
        .nan_double = fd(16, .{ .scalar = .double }),
        .inf_float = fd(17, .{ .scalar = .float }),
        .neg_inf_float = fd(18, .{ .scalar = .float }),
        .nan_float = fd(19, .{ .scalar = .float }),
        .cpp_trigraph = fd(20, .{ .scalar = .string }),
        .string_with_zero = fd(23, .{ .scalar = .string }),
        .bytes_with_zero = fd(24, .{ .scalar = .bytes }),
        .string_piece_with_zero = fd(25, .{ .scalar = .string }),
        .cord_with_zero = fd(26, .{ .scalar = .string }),
        .replacement_string = fd(27, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const SparseEnumMessage = struct {
    sparse_enum: ?TestSparseEnum = null,

    pub const _desc_table = .{
        .sparse_enum = fd(1, .@"enum"),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Test String and Bytes: string is for valid UTF-8 strings
pub const OneString = struct {
    data: ?[]const u8 = null,

    pub const _desc_table = .{
        .data = fd(1, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const MoreString = struct {
    data: std.ArrayListUnmanaged([]const u8) = .empty,

    pub const _desc_table = .{
        .data = fd(1, .{ .repeated = .{ .scalar = .string } }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const OneBytes = struct {
    data: ?[]const u8 = null,

    pub const _desc_table = .{
        .data = fd(1, .{ .scalar = .bytes }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const MoreBytes = struct {
    data: std.ArrayListUnmanaged([]const u8) = .empty,

    pub const _desc_table = .{
        .data = fd(1, .{ .repeated = .{ .scalar = .bytes } }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const ManyOptionalString = struct {
    str1: ?[]const u8 = null,
    str2: ?[]const u8 = null,
    str3: ?[]const u8 = null,
    str4: ?[]const u8 = null,
    str5: ?[]const u8 = null,
    str6: ?[]const u8 = null,
    str7: ?[]const u8 = null,
    str8: ?[]const u8 = null,
    str9: ?[]const u8 = null,
    str10: ?[]const u8 = null,
    str11: ?[]const u8 = null,
    str12: ?[]const u8 = null,
    str13: ?[]const u8 = null,
    str14: ?[]const u8 = null,
    str15: ?[]const u8 = null,
    str16: ?[]const u8 = null,
    str17: ?[]const u8 = null,
    str18: ?[]const u8 = null,
    str19: ?[]const u8 = null,
    str20: ?[]const u8 = null,
    str21: ?[]const u8 = null,
    str22: ?[]const u8 = null,
    str23: ?[]const u8 = null,
    str24: ?[]const u8 = null,
    str25: ?[]const u8 = null,
    str26: ?[]const u8 = null,
    str27: ?[]const u8 = null,
    str28: ?[]const u8 = null,
    str29: ?[]const u8 = null,
    str30: ?[]const u8 = null,
    str31: ?[]const u8 = null,
    str32: ?[]const u8 = null,

    pub const _desc_table = .{
        .str1 = fd(1, .{ .scalar = .string }),
        .str2 = fd(2, .{ .scalar = .string }),
        .str3 = fd(3, .{ .scalar = .string }),
        .str4 = fd(4, .{ .scalar = .string }),
        .str5 = fd(5, .{ .scalar = .string }),
        .str6 = fd(6, .{ .scalar = .string }),
        .str7 = fd(7, .{ .scalar = .string }),
        .str8 = fd(8, .{ .scalar = .string }),
        .str9 = fd(9, .{ .scalar = .string }),
        .str10 = fd(10, .{ .scalar = .string }),
        .str11 = fd(11, .{ .scalar = .string }),
        .str12 = fd(12, .{ .scalar = .string }),
        .str13 = fd(13, .{ .scalar = .string }),
        .str14 = fd(14, .{ .scalar = .string }),
        .str15 = fd(15, .{ .scalar = .string }),
        .str16 = fd(16, .{ .scalar = .string }),
        .str17 = fd(17, .{ .scalar = .string }),
        .str18 = fd(18, .{ .scalar = .string }),
        .str19 = fd(19, .{ .scalar = .string }),
        .str20 = fd(20, .{ .scalar = .string }),
        .str21 = fd(21, .{ .scalar = .string }),
        .str22 = fd(22, .{ .scalar = .string }),
        .str23 = fd(23, .{ .scalar = .string }),
        .str24 = fd(24, .{ .scalar = .string }),
        .str25 = fd(25, .{ .scalar = .string }),
        .str26 = fd(26, .{ .scalar = .string }),
        .str27 = fd(27, .{ .scalar = .string }),
        .str28 = fd(28, .{ .scalar = .string }),
        .str29 = fd(29, .{ .scalar = .string }),
        .str30 = fd(30, .{ .scalar = .string }),
        .str31 = fd(31, .{ .scalar = .string }),
        .str32 = fd(32, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Test int32, uint32, int64, uint64, and bool are all compatible
pub const Int32Message = struct {
    data: ?i32 = null,

    pub const _desc_table = .{
        .data = fd(1, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const Uint32Message = struct {
    data: ?u32 = null,

    pub const _desc_table = .{
        .data = fd(1, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const Int64Message = struct {
    data: ?i64 = null,

    pub const _desc_table = .{
        .data = fd(1, .{ .scalar = .int64 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const Uint64Message = struct {
    data: ?u64 = null,

    pub const _desc_table = .{
        .data = fd(1, .{ .scalar = .uint64 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const BoolMessage = struct {
    data: ?bool = null,

    pub const _desc_table = .{
        .data = fd(1, .{ .scalar = .bool }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Test oneofs.
pub const TestOneof = struct {
    foo: ?foo_union = null,

    pub const _foo_case = enum {
        foo_int,
        foo_string,
        foo_message,
        a,
        b,
    };
    pub const foo_union = union(_foo_case) {
        foo_int: i32,
        foo_string: []const u8,
        foo_message: TestAllTypes,
        a: i32,
        b: []const u8,
        pub const _desc_table = .{
            .foo_int = fd(1, .{ .scalar = .int32 }),
            .foo_string = fd(2, .{ .scalar = .string }),
            .foo_message = fd(3, .submessage),
            .a = fd(5, .{ .scalar = .int32 }),
            .b = fd(6, .{ .scalar = .string }),
        };
    };

    pub const _desc_table = .{
        .foo = fd(null, .{ .oneof = foo_union }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestOneofBackwardsCompatible = struct {
    foo_int: ?i32 = null,
    foo_string: ?[]const u8 = null,
    foo_message: ?TestAllTypes = null,
    a: ?i32 = null,
    b: ?[]const u8 = null,

    pub const _desc_table = .{
        .foo_int = fd(1, .{ .scalar = .int32 }),
        .foo_string = fd(2, .{ .scalar = .string }),
        .foo_message = fd(3, .submessage),
        .a = fd(5, .{ .scalar = .int32 }),
        .b = fd(6, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestOneof2 = struct {
    baz_int: ?i32 = null,
    baz_string: ?[]const u8 = "BAZ",
    foo: ?foo_union = null,
    bar: ?bar_union = null,

    pub const _foo_case = enum {
        foo_int,
        foo_string,
        foo_cord,
        foo_string_piece,
        foo_bytes,
        foo_enum,
        foo_message,
        a,
        b,
        foo_lazy_message,
    };
    pub const foo_union = union(_foo_case) {
        foo_int: i32,
        foo_string: []const u8,
        foo_cord: []const u8,
        foo_string_piece: []const u8,
        foo_bytes: []const u8,
        foo_enum: TestOneof2.NestedEnum,
        foo_message: TestOneof2.NestedMessage,
        a: i32,
        b: []const u8,
        foo_lazy_message: TestOneof2.NestedMessage,
        pub const _desc_table = .{
            .foo_int = fd(1, .{ .scalar = .int32 }),
            .foo_string = fd(2, .{ .scalar = .string }),
            .foo_cord = fd(3, .{ .scalar = .string }),
            .foo_string_piece = fd(4, .{ .scalar = .string }),
            .foo_bytes = fd(5, .{ .scalar = .bytes }),
            .foo_enum = fd(6, .@"enum"),
            .foo_message = fd(7, .submessage),
            .a = fd(9, .{ .scalar = .int32 }),
            .b = fd(10, .{ .scalar = .string }),
            .foo_lazy_message = fd(11, .submessage),
        };
    };

    pub const _bar_case = enum {
        bar_int,
        bar_string,
        bar_cord,
        bar_string_piece,
        bar_bytes,
        bar_enum,
        bar_string_with_empty_default,
        bar_cord_with_empty_default,
        bar_string_piece_with_empty_default,
        bar_bytes_with_empty_default,
    };
    pub const bar_union = union(_bar_case) {
        bar_int: i32,
        bar_string: []const u8,
        bar_cord: []const u8,
        bar_string_piece: []const u8,
        bar_bytes: []const u8,
        bar_enum: TestOneof2.NestedEnum,
        bar_string_with_empty_default: []const u8,
        bar_cord_with_empty_default: []const u8,
        bar_string_piece_with_empty_default: []const u8,
        bar_bytes_with_empty_default: []const u8,
        pub const _desc_table = .{
            .bar_int = fd(12, .{ .scalar = .int32 }),
            .bar_string = fd(13, .{ .scalar = .string }),
            .bar_cord = fd(14, .{ .scalar = .string }),
            .bar_string_piece = fd(15, .{ .scalar = .string }),
            .bar_bytes = fd(16, .{ .scalar = .bytes }),
            .bar_enum = fd(17, .@"enum"),
            .bar_string_with_empty_default = fd(20, .{ .scalar = .string }),
            .bar_cord_with_empty_default = fd(21, .{ .scalar = .string }),
            .bar_string_piece_with_empty_default = fd(22, .{ .scalar = .string }),
            .bar_bytes_with_empty_default = fd(23, .{ .scalar = .bytes }),
        };
    };

    pub const _desc_table = .{
        .baz_int = fd(18, .{ .scalar = .int32 }),
        .baz_string = fd(19, .{ .scalar = .string }),
        .foo = fd(null, .{ .oneof = foo_union }),
        .bar = fd(null, .{ .oneof = bar_union }),
    };

    pub const NestedEnum = enum(i32) {
        FOO = 1,
        BAR = 2,
        BAZ = 3,
        _,
    };

    pub const NestedMessage = struct {
        moo_int: ?i64 = null,
        corge_int: std.ArrayListUnmanaged(i32) = .empty,

        pub const _desc_table = .{
            .moo_int = fd(1, .{ .scalar = .int64 }),
            .corge_int = fd(2, .{ .repeated = .{ .scalar = .int32 } }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestRequiredOneof = struct {
    foo: ?foo_union = null,

    pub const _foo_case = enum {
        foo_int,
        foo_string,
        foo_message,
    };
    pub const foo_union = union(_foo_case) {
        foo_int: i32,
        foo_string: []const u8,
        foo_message: TestRequiredOneof.NestedMessage,
        pub const _desc_table = .{
            .foo_int = fd(1, .{ .scalar = .int32 }),
            .foo_string = fd(2, .{ .scalar = .string }),
            .foo_message = fd(3, .submessage),
        };
    };

    pub const _desc_table = .{
        .foo = fd(null, .{ .oneof = foo_union }),
    };

    pub const NestedMessage = struct {
        required_double: f64,

        pub const _desc_table = .{
            .required_double = fd(1, .{ .scalar = .double }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestPackedTypes = struct {
    packed_int32: std.ArrayListUnmanaged(i32) = .empty,
    packed_int64: std.ArrayListUnmanaged(i64) = .empty,
    packed_uint32: std.ArrayListUnmanaged(u32) = .empty,
    packed_uint64: std.ArrayListUnmanaged(u64) = .empty,
    packed_sint32: std.ArrayListUnmanaged(i32) = .empty,
    packed_sint64: std.ArrayListUnmanaged(i64) = .empty,
    packed_fixed32: std.ArrayListUnmanaged(u32) = .empty,
    packed_fixed64: std.ArrayListUnmanaged(u64) = .empty,
    packed_sfixed32: std.ArrayListUnmanaged(i32) = .empty,
    packed_sfixed64: std.ArrayListUnmanaged(i64) = .empty,
    packed_float: std.ArrayListUnmanaged(f32) = .empty,
    packed_double: std.ArrayListUnmanaged(f64) = .empty,
    packed_bool: std.ArrayListUnmanaged(bool) = .empty,
    packed_enum: std.ArrayListUnmanaged(ForeignEnum) = .empty,

    pub const _desc_table = .{
        .packed_int32 = fd(90, .{ .packed_repeated = .{ .scalar = .int32 } }),
        .packed_int64 = fd(91, .{ .packed_repeated = .{ .scalar = .int64 } }),
        .packed_uint32 = fd(92, .{ .packed_repeated = .{ .scalar = .uint32 } }),
        .packed_uint64 = fd(93, .{ .packed_repeated = .{ .scalar = .uint64 } }),
        .packed_sint32 = fd(94, .{ .packed_repeated = .{ .scalar = .sint32 } }),
        .packed_sint64 = fd(95, .{ .packed_repeated = .{ .scalar = .sint64 } }),
        .packed_fixed32 = fd(96, .{ .packed_repeated = .{ .scalar = .fixed32 } }),
        .packed_fixed64 = fd(97, .{ .packed_repeated = .{ .scalar = .fixed64 } }),
        .packed_sfixed32 = fd(98, .{ .packed_repeated = .{ .scalar = .sfixed32 } }),
        .packed_sfixed64 = fd(99, .{ .packed_repeated = .{ .scalar = .sfixed64 } }),
        .packed_float = fd(100, .{ .packed_repeated = .{ .scalar = .float } }),
        .packed_double = fd(101, .{ .packed_repeated = .{ .scalar = .double } }),
        .packed_bool = fd(102, .{ .packed_repeated = .{ .scalar = .bool } }),
        .packed_enum = fd(103, .{ .packed_repeated = .@"enum" }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// A message with the same fields as TestPackedTypes, but without packing. Used
/// to test packed <-> unpacked wire compatibility.
pub const TestUnpackedTypes = struct {
    unpacked_int32: std.ArrayListUnmanaged(i32) = .empty,
    unpacked_int64: std.ArrayListUnmanaged(i64) = .empty,
    unpacked_uint32: std.ArrayListUnmanaged(u32) = .empty,
    unpacked_uint64: std.ArrayListUnmanaged(u64) = .empty,
    unpacked_sint32: std.ArrayListUnmanaged(i32) = .empty,
    unpacked_sint64: std.ArrayListUnmanaged(i64) = .empty,
    unpacked_fixed32: std.ArrayListUnmanaged(u32) = .empty,
    unpacked_fixed64: std.ArrayListUnmanaged(u64) = .empty,
    unpacked_sfixed32: std.ArrayListUnmanaged(i32) = .empty,
    unpacked_sfixed64: std.ArrayListUnmanaged(i64) = .empty,
    unpacked_float: std.ArrayListUnmanaged(f32) = .empty,
    unpacked_double: std.ArrayListUnmanaged(f64) = .empty,
    unpacked_bool: std.ArrayListUnmanaged(bool) = .empty,
    unpacked_enum: std.ArrayListUnmanaged(ForeignEnum) = .empty,

    pub const _desc_table = .{
        .unpacked_int32 = fd(90, .{ .repeated = .{ .scalar = .int32 } }),
        .unpacked_int64 = fd(91, .{ .repeated = .{ .scalar = .int64 } }),
        .unpacked_uint32 = fd(92, .{ .repeated = .{ .scalar = .uint32 } }),
        .unpacked_uint64 = fd(93, .{ .repeated = .{ .scalar = .uint64 } }),
        .unpacked_sint32 = fd(94, .{ .repeated = .{ .scalar = .sint32 } }),
        .unpacked_sint64 = fd(95, .{ .repeated = .{ .scalar = .sint64 } }),
        .unpacked_fixed32 = fd(96, .{ .repeated = .{ .scalar = .fixed32 } }),
        .unpacked_fixed64 = fd(97, .{ .repeated = .{ .scalar = .fixed64 } }),
        .unpacked_sfixed32 = fd(98, .{ .repeated = .{ .scalar = .sfixed32 } }),
        .unpacked_sfixed64 = fd(99, .{ .repeated = .{ .scalar = .sfixed64 } }),
        .unpacked_float = fd(100, .{ .repeated = .{ .scalar = .float } }),
        .unpacked_double = fd(101, .{ .repeated = .{ .scalar = .double } }),
        .unpacked_bool = fd(102, .{ .repeated = .{ .scalar = .bool } }),
        .unpacked_enum = fd(103, .{ .repeated = .@"enum" }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestPackedExtensions = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestUnpackedExtensions = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
/// a set of extensions to TestAllExtensions dynamically, based on the fields
/// of this message type.
pub const TestDynamicExtensions = struct {
    scalar_extension: ?u32 = null,
    enum_extension: ?ForeignEnum = null,
    dynamic_enum_extension: ?TestDynamicExtensions.DynamicEnumType = null,
    message_extension: ?ForeignMessage = null,
    dynamic_message_extension: ?TestDynamicExtensions.DynamicMessageType = null,
    repeated_extension: std.ArrayListUnmanaged([]const u8) = .empty,
    packed_extension: std.ArrayListUnmanaged(i32) = .empty,

    pub const _desc_table = .{
        .scalar_extension = fd(2000, .{ .scalar = .fixed32 }),
        .enum_extension = fd(2001, .@"enum"),
        .dynamic_enum_extension = fd(2002, .@"enum"),
        .message_extension = fd(2003, .submessage),
        .dynamic_message_extension = fd(2004, .submessage),
        .repeated_extension = fd(2005, .{ .repeated = .{ .scalar = .string } }),
        .packed_extension = fd(2006, .{ .packed_repeated = .{ .scalar = .sint32 } }),
    };

    pub const DynamicEnumType = enum(i32) {
        DYNAMIC_FOO = 2200,
        DYNAMIC_BAR = 2201,
        DYNAMIC_BAZ = 2202,
        _,
    };

    pub const DynamicMessageType = struct {
        dynamic_field: ?i32 = null,

        pub const _desc_table = .{
            .dynamic_field = fd(2100, .{ .scalar = .int32 }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestRepeatedScalarDifferentTagSizes = struct {
    repeated_fixed32: std.ArrayListUnmanaged(u32) = .empty,
    repeated_int32: std.ArrayListUnmanaged(i32) = .empty,
    repeated_fixed64: std.ArrayListUnmanaged(u64) = .empty,
    repeated_int64: std.ArrayListUnmanaged(i64) = .empty,
    repeated_float: std.ArrayListUnmanaged(f32) = .empty,
    repeated_uint64: std.ArrayListUnmanaged(u64) = .empty,

    pub const _desc_table = .{
        .repeated_fixed32 = fd(12, .{ .repeated = .{ .scalar = .fixed32 } }),
        .repeated_int32 = fd(13, .{ .repeated = .{ .scalar = .int32 } }),
        .repeated_fixed64 = fd(2046, .{ .repeated = .{ .scalar = .fixed64 } }),
        .repeated_int64 = fd(2047, .{ .repeated = .{ .scalar = .int64 } }),
        .repeated_float = fd(262142, .{ .repeated = .{ .scalar = .float } }),
        .repeated_uint64 = fd(262143, .{ .repeated = .{ .scalar = .uint64 } }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Test that if an optional or required message/group field appears multiple
/// times in the input, they need to be merged.
pub const TestParsingMerge = struct {
    required_all_types: ?TestAllTypes = null,
    optional_all_types: ?TestAllTypes = null,
    repeated_all_types: std.ArrayListUnmanaged(TestAllTypes) = .empty,
    optional_group_all_types: ?TestAllTypes = null,
    repeated_group_all_types: ?TestAllTypes = null,

    pub const _desc_table = .{
        .required_all_types = fd(1, .submessage),
        .optional_all_types = fd(2, .submessage),
        .repeated_all_types = fd(3, .{ .repeated = .submessage }),
        .optional_group_all_types = fd(11, .submessage),
        .repeated_group_all_types = fd(21, .submessage),
    };

    /// RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
    /// except that all fields are repeated. In the tests, we will serialize the
    /// RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
    /// Repeated fields in RepeatedFieldsGenerator are expected to be merged into
    /// the corresponding required/optional fields in TestParsingMerge.
    pub const RepeatedFieldsGenerator = struct {
        field1: std.ArrayListUnmanaged(TestAllTypes) = .empty,
        field2: std.ArrayListUnmanaged(TestAllTypes) = .empty,
        field3: std.ArrayListUnmanaged(TestAllTypes) = .empty,
        Group1_field1: ?TestAllTypes = null,
        Group2_field1: ?TestAllTypes = null,
        ext1: std.ArrayListUnmanaged(TestAllTypes) = .empty,
        ext2: std.ArrayListUnmanaged(TestAllTypes) = .empty,

        pub const _desc_table = .{
            .field1 = fd(1, .{ .repeated = .submessage }),
            .field2 = fd(2, .{ .repeated = .submessage }),
            .field3 = fd(3, .{ .repeated = .submessage }),
            .Group1_field1 = fd(11, .submessage),
            .Group2_field1 = fd(21, .submessage),
            .ext1 = fd(1000, .{ .repeated = .submessage }),
            .ext2 = fd(1001, .{ .repeated = .submessage }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Test that the correct exception is thrown by parseFrom in a corner case
/// involving merging, extensions, and required fields.
pub const TestMergeException = struct {
    all_extensions: ?TestAllExtensions = null,

    pub const _desc_table = .{
        .all_extensions = fd(1, .submessage),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestCommentInjectionMessage = struct {
    a: ?[]const u8 = "*/ <- Neither should this.",

    pub const _desc_table = .{
        .a = fd(1, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Used to check that the c++ code generator re-orders messages to reduce
/// padding.
pub const TestMessageSize = struct {
    m1: ?bool = null,
    m2: ?i64 = null,
    m3: ?bool = null,
    m4: ?[]const u8 = null,
    m5: ?i32 = null,
    m6: ?i64 = null,

    pub const _desc_table = .{
        .m1 = fd(1, .{ .scalar = .bool }),
        .m2 = fd(2, .{ .scalar = .int64 }),
        .m3 = fd(3, .{ .scalar = .bool }),
        .m4 = fd(4, .{ .scalar = .string }),
        .m5 = fd(5, .{ .scalar = .int32 }),
        .m6 = fd(6, .{ .scalar = .int64 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// Test that RPC services work.
pub const FooRequest = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const FooResponse = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const FooClientMessage = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const FooServerMessage = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const BarRequest = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const BarResponse = struct {
    pub const _desc_table = .{};

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestJsonName = struct {
    field_name1: ?i32 = null,
    fieldName2: ?i32 = null,
    FieldName3: ?i32 = null,
    _field_name4: ?i32 = null,
    FIELD_NAME5: ?i32 = null,
    field_name6: ?i32 = null,
    fieldname7: ?i32 = null,

    pub const _desc_table = .{
        .field_name1 = fd(1, .{ .scalar = .int32 }),
        .fieldName2 = fd(2, .{ .scalar = .int32 }),
        .FieldName3 = fd(3, .{ .scalar = .int32 }),
        ._field_name4 = fd(4, .{ .scalar = .int32 }),
        .FIELD_NAME5 = fd(5, .{ .scalar = .int32 }),
        .field_name6 = fd(6, .{ .scalar = .int32 }),
        .fieldname7 = fd(7, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestHugeFieldNumbers = struct {
    optional_int32: ?i32 = null,
    fixed_32: ?i32 = null,
    repeated_int32: std.ArrayListUnmanaged(i32) = .empty,
    packed_int32: std.ArrayListUnmanaged(i32) = .empty,
    optional_enum: ?ForeignEnum = null,
    optional_string: ?[]const u8 = null,
    optional_bytes: ?[]const u8 = null,
    optional_message: ?ForeignMessage = null,
    group_a: ?i32 = null,
    string_string_map: std.ArrayListUnmanaged(TestHugeFieldNumbers.StringStringMapEntry) = .empty,
    oneof_field: ?oneof_field_union = null,

    pub const _oneof_field_case = enum {
        oneof_uint32,
        oneof_test_all_types,
        oneof_string,
        oneof_bytes,
    };
    pub const oneof_field_union = union(_oneof_field_case) {
        oneof_uint32: u32,
        oneof_test_all_types: TestAllTypes,
        oneof_string: []const u8,
        oneof_bytes: []const u8,
        pub const _desc_table = .{
            .oneof_uint32 = fd(536870011, .{ .scalar = .uint32 }),
            .oneof_test_all_types = fd(536870012, .submessage),
            .oneof_string = fd(536870013, .{ .scalar = .string }),
            .oneof_bytes = fd(536870014, .{ .scalar = .bytes }),
        };
    };

    pub const _desc_table = .{
        .optional_int32 = fd(536870000, .{ .scalar = .int32 }),
        .fixed_32 = fd(536870001, .{ .scalar = .int32 }),
        .repeated_int32 = fd(536870002, .{ .repeated = .{ .scalar = .int32 } }),
        .packed_int32 = fd(536870003, .{ .packed_repeated = .{ .scalar = .int32 } }),
        .optional_enum = fd(536870004, .@"enum"),
        .optional_string = fd(536870005, .{ .scalar = .string }),
        .optional_bytes = fd(536870006, .{ .scalar = .bytes }),
        .optional_message = fd(536870007, .submessage),
        .group_a = fd(536870009, .{ .scalar = .int32 }),
        .string_string_map = fd(536870010, .{ .repeated = .submessage }),
        .oneof_field = fd(null, .{ .oneof = oneof_field_union }),
    };

    pub const StringStringMapEntry = struct {
        key: ?[]const u8 = null,
        value: ?[]const u8 = null,

        pub const _desc_table = .{
            .key = fd(1, .{ .scalar = .string }),
            .value = fd(2, .{ .scalar = .string }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestExtensionInsideTable = struct {
    field1: ?i32 = null,
    field2: ?i32 = null,
    field3: ?i32 = null,
    field4: ?i32 = null,
    field6: ?i32 = null,
    field7: ?i32 = null,
    field8: ?i32 = null,
    field9: ?i32 = null,
    field10: ?i32 = null,

    pub const _desc_table = .{
        .field1 = fd(1, .{ .scalar = .int32 }),
        .field2 = fd(2, .{ .scalar = .int32 }),
        .field3 = fd(3, .{ .scalar = .int32 }),
        .field4 = fd(4, .{ .scalar = .int32 }),
        .field6 = fd(6, .{ .scalar = .int32 }),
        .field7 = fd(7, .{ .scalar = .int32 }),
        .field8 = fd(8, .{ .scalar = .int32 }),
        .field9 = fd(9, .{ .scalar = .int32 }),
        .field10 = fd(10, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestNestedGroupExtensionInnerExtension = struct {
    inner_name: ?[]const u8 = null,

    pub const _desc_table = .{
        .inner_name = fd(1, .{ .scalar = .string }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestExtensionRangeSerialize = struct {
    foo_one: ?i32 = null,
    foo_two: ?i32 = null,
    foo_three: ?i32 = null,
    foo_four: ?i32 = null,

    pub const _desc_table = .{
        .foo_one = fd(1, .{ .scalar = .int32 }),
        .foo_two = fd(6, .{ .scalar = .int32 }),
        .foo_three = fd(7, .{ .scalar = .int32 }),
        .foo_four = fd(13, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestVerifyInt32Simple = struct {
    optional_int32_1: ?i32 = null,
    optional_int32_2: ?i32 = null,
    optional_int32_63: ?i32 = null,
    optional_int32_64: ?i32 = null,

    pub const _desc_table = .{
        .optional_int32_1 = fd(1, .{ .scalar = .int32 }),
        .optional_int32_2 = fd(2, .{ .scalar = .int32 }),
        .optional_int32_63 = fd(63, .{ .scalar = .int32 }),
        .optional_int32_64 = fd(64, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestVerifyInt32 = struct {
    optional_int32_1: ?i32 = null,
    optional_int32_2: ?i32 = null,
    optional_int32_63: ?i32 = null,
    optional_int32_64: ?i32 = null,
    optional_all_types: ?TestAllTypes = null,
    repeated_all_types: std.ArrayListUnmanaged(TestAllTypes) = .empty,

    pub const _desc_table = .{
        .optional_int32_1 = fd(1, .{ .scalar = .int32 }),
        .optional_int32_2 = fd(2, .{ .scalar = .int32 }),
        .optional_int32_63 = fd(63, .{ .scalar = .int32 }),
        .optional_int32_64 = fd(64, .{ .scalar = .int32 }),
        .optional_all_types = fd(9, .submessage),
        .repeated_all_types = fd(10, .{ .repeated = .submessage }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestVerifyMostlyInt32 = struct {
    optional_int64_30: ?i64 = null,
    optional_int32_1: ?i32 = null,
    optional_int32_2: ?i32 = null,
    optional_int32_3: ?i32 = null,
    optional_int32_4: ?i32 = null,
    optional_int32_63: ?i32 = null,
    optional_int32_64: ?i32 = null,
    optional_all_types: ?TestAllTypes = null,
    repeated_all_types: std.ArrayListUnmanaged(TestAllTypes) = .empty,

    pub const _desc_table = .{
        .optional_int64_30 = fd(30, .{ .scalar = .int64 }),
        .optional_int32_1 = fd(1, .{ .scalar = .int32 }),
        .optional_int32_2 = fd(2, .{ .scalar = .int32 }),
        .optional_int32_3 = fd(3, .{ .scalar = .int32 }),
        .optional_int32_4 = fd(4, .{ .scalar = .int32 }),
        .optional_int32_63 = fd(63, .{ .scalar = .int32 }),
        .optional_int32_64 = fd(64, .{ .scalar = .int32 }),
        .optional_all_types = fd(9, .submessage),
        .repeated_all_types = fd(10, .{ .repeated = .submessage }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestVerifyMostlyInt32BigFieldNumber = struct {
    optional_int64_30: ?i64 = null,
    optional_int32_300: ?i32 = null,
    optional_int32_1: ?i32 = null,
    optional_int32_2: ?i32 = null,
    optional_int32_3: ?i32 = null,
    optional_int32_4: ?i32 = null,
    optional_int32_63: ?i32 = null,
    optional_int32_64: ?i32 = null,
    optional_all_types: ?TestAllTypes = null,
    repeated_all_types: std.ArrayListUnmanaged(TestAllTypes) = .empty,

    pub const _desc_table = .{
        .optional_int64_30 = fd(30, .{ .scalar = .int64 }),
        .optional_int32_300 = fd(300, .{ .scalar = .int32 }),
        .optional_int32_1 = fd(1, .{ .scalar = .int32 }),
        .optional_int32_2 = fd(2, .{ .scalar = .int32 }),
        .optional_int32_3 = fd(3, .{ .scalar = .int32 }),
        .optional_int32_4 = fd(4, .{ .scalar = .int32 }),
        .optional_int32_63 = fd(63, .{ .scalar = .int32 }),
        .optional_int32_64 = fd(64, .{ .scalar = .int32 }),
        .optional_all_types = fd(9, .submessage),
        .repeated_all_types = fd(10, .{ .repeated = .submessage }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestVerifyUint32Simple = struct {
    optional_uint32_1: ?u32 = null,
    optional_uint32_2: ?u32 = null,
    optional_uint32_63: ?u32 = null,
    optional_uint32_64: ?u32 = null,

    pub const _desc_table = .{
        .optional_uint32_1 = fd(1, .{ .scalar = .uint32 }),
        .optional_uint32_2 = fd(2, .{ .scalar = .uint32 }),
        .optional_uint32_63 = fd(63, .{ .scalar = .uint32 }),
        .optional_uint32_64 = fd(64, .{ .scalar = .uint32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestVerifyUint32 = struct {
    optional_uint32_1: ?u32 = null,
    optional_uint32_2: ?u32 = null,
    optional_uint32_63: ?u32 = null,
    optional_uint32_64: ?u32 = null,
    optional_all_types: ?TestAllTypes = null,
    repeated_all_types: std.ArrayListUnmanaged(TestAllTypes) = .empty,

    pub const _desc_table = .{
        .optional_uint32_1 = fd(1, .{ .scalar = .uint32 }),
        .optional_uint32_2 = fd(2, .{ .scalar = .uint32 }),
        .optional_uint32_63 = fd(63, .{ .scalar = .uint32 }),
        .optional_uint32_64 = fd(64, .{ .scalar = .uint32 }),
        .optional_all_types = fd(9, .submessage),
        .repeated_all_types = fd(10, .{ .repeated = .submessage }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestVerifyOneUint32 = struct {
    optional_uint32_1: ?u32 = null,
    optional_int32_2: ?i32 = null,
    optional_int32_63: ?i32 = null,
    optional_int32_64: ?i32 = null,
    optional_all_types: ?TestAllTypes = null,
    repeated_all_types: std.ArrayListUnmanaged(TestAllTypes) = .empty,

    pub const _desc_table = .{
        .optional_uint32_1 = fd(1, .{ .scalar = .uint32 }),
        .optional_int32_2 = fd(2, .{ .scalar = .int32 }),
        .optional_int32_63 = fd(63, .{ .scalar = .int32 }),
        .optional_int32_64 = fd(64, .{ .scalar = .int32 }),
        .optional_all_types = fd(9, .submessage),
        .repeated_all_types = fd(10, .{ .repeated = .submessage }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestVerifyOneInt32BigFieldNumber = struct {
    optional_int32_65: ?i32 = null,
    optional_int64_1: ?i64 = null,
    optional_int64_2: ?i64 = null,
    optional_int64_63: ?i64 = null,
    optional_int64_64: ?i64 = null,
    optional_all_types: ?TestAllTypes = null,
    repeated_all_types: std.ArrayListUnmanaged(TestAllTypes) = .empty,

    pub const _desc_table = .{
        .optional_int32_65 = fd(65, .{ .scalar = .int32 }),
        .optional_int64_1 = fd(1, .{ .scalar = .int64 }),
        .optional_int64_2 = fd(2, .{ .scalar = .int64 }),
        .optional_int64_63 = fd(63, .{ .scalar = .int64 }),
        .optional_int64_64 = fd(64, .{ .scalar = .int64 }),
        .optional_all_types = fd(9, .submessage),
        .repeated_all_types = fd(10, .{ .repeated = .submessage }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestVerifyInt32BigFieldNumber = struct {
    optional_int32_1000: ?i32 = null,
    optional_int32_65: ?i32 = null,
    optional_int32_1: ?i32 = null,
    optional_int32_2: ?i32 = null,
    optional_int32_63: ?i32 = null,
    optional_int32_64: ?i32 = null,
    optional_all_types: ?TestAllTypes = null,
    repeated_all_types: std.ArrayListUnmanaged(TestAllTypes) = .empty,

    pub const _desc_table = .{
        .optional_int32_1000 = fd(1000, .{ .scalar = .int32 }),
        .optional_int32_65 = fd(65, .{ .scalar = .int32 }),
        .optional_int32_1 = fd(1, .{ .scalar = .int32 }),
        .optional_int32_2 = fd(2, .{ .scalar = .int32 }),
        .optional_int32_63 = fd(63, .{ .scalar = .int32 }),
        .optional_int32_64 = fd(64, .{ .scalar = .int32 }),
        .optional_all_types = fd(9, .submessage),
        .repeated_all_types = fd(10, .{ .repeated = .submessage }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestVerifyUint32BigFieldNumber = struct {
    optional_uint32_1000: ?u32 = null,
    optional_uint32_65: ?u32 = null,
    optional_uint32_1: ?u32 = null,
    optional_uint32_2: ?u32 = null,
    optional_uint32_63: ?u32 = null,
    optional_uint32_64: ?u32 = null,
    optional_all_types: ?TestAllTypes = null,
    repeated_all_types: std.ArrayListUnmanaged(TestAllTypes) = .empty,

    pub const _desc_table = .{
        .optional_uint32_1000 = fd(1000, .{ .scalar = .uint32 }),
        .optional_uint32_65 = fd(65, .{ .scalar = .uint32 }),
        .optional_uint32_1 = fd(1, .{ .scalar = .uint32 }),
        .optional_uint32_2 = fd(2, .{ .scalar = .uint32 }),
        .optional_uint32_63 = fd(63, .{ .scalar = .uint32 }),
        .optional_uint32_64 = fd(64, .{ .scalar = .uint32 }),
        .optional_all_types = fd(9, .submessage),
        .repeated_all_types = fd(10, .{ .repeated = .submessage }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub const TestVerifyBigFieldNumberUint32 = struct {
    optional_nested: ?TestVerifyBigFieldNumberUint32.Nested = null,

    pub const _desc_table = .{
        .optional_nested = fd(1, .submessage),
    };

    pub const Nested = struct {
        optional_uint32_5000: ?u32 = null,
        optional_uint32_1000: ?u32 = null,
        optional_uint32_66: ?u32 = null,
        optional_uint32_65: ?u32 = null,
        optional_uint32_1: ?u32 = null,
        optional_uint32_2: ?u32 = null,
        optional_uint32_63: ?u32 = null,
        optional_uint32_64: ?u32 = null,
        optional_nested: ?*TestVerifyBigFieldNumberUint32.Nested = null,
        repeated_nested: std.ArrayListUnmanaged(TestVerifyBigFieldNumberUint32.Nested) = .empty,

        pub const _desc_table = .{
            .optional_uint32_5000 = fd(5000, .{ .scalar = .uint32 }),
            .optional_uint32_1000 = fd(1000, .{ .scalar = .uint32 }),
            .optional_uint32_66 = fd(66, .{ .scalar = .uint32 }),
            .optional_uint32_65 = fd(65, .{ .scalar = .uint32 }),
            .optional_uint32_1 = fd(1, .{ .scalar = .uint32 }),
            .optional_uint32_2 = fd(2, .{ .scalar = .uint32 }),
            .optional_uint32_63 = fd(63, .{ .scalar = .uint32 }),
            .optional_uint32_64 = fd(64, .{ .scalar = .uint32 }),
            .optional_nested = fd(9, .submessage),
            .repeated_nested = fd(10, .{ .repeated = .submessage }),
        };

        /// Encodes the message to the writer
        /// The allocator is used to generate submessages internally.
        /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
        pub fn encode(
            self: @This(),
            writer: *std.Io.Writer,
            allocator: std.mem.Allocator,
        ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
            return protobuf.encode(writer, allocator, self);
        }

        /// Decodes the message from the bytes read from the reader.
        pub fn decode(
            reader: *std.Io.Reader,
            allocator: std.mem.Allocator,
        ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
            return protobuf.decode(@This(), reader, allocator);
        }

        /// Deinitializes and frees the memory associated with the message.
        pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
            return protobuf.deinit(allocator, self);
        }

        /// Duplicates the message.
        pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
            return protobuf.dupe(@This(), self, allocator);
        }

        /// Decodes the message from the JSON string.
        pub fn jsonDecode(
            input: []const u8,
            options: std.json.ParseOptions,
            allocator: std.mem.Allocator,
        ) !std.json.Parsed(@This()) {
            return protobuf.json.decode(@This(), input, options, allocator);
        }

        /// Encodes the message to a JSON string.
        pub fn jsonEncode(
            self: @This(),
            options: std.json.Stringify.Options,
            allocator: std.mem.Allocator,
        ) ![]const u8 {
            return protobuf.json.encode(self, options, allocator);
        }

        /// This method is used by std.json
        /// internally for deserialization. DO NOT RENAME!
        pub fn jsonParse(
            allocator: std.mem.Allocator,
            source: anytype,
            options: std.json.ParseOptions,
        ) !@This() {
            return protobuf.json.parse(@This(), allocator, source, options);
        }

        /// This method is used by std.json
        /// internally for serialization. DO NOT RENAME!
        pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
            return protobuf.json.stringify(@This(), self, jws);
        }
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// This message contains different kind of enums to exercise the different
/// parsers in table-driven.
pub const EnumParseTester = struct {
    optional_seq_small_0_lowfield: ?EnumParseTester.SeqSmall0 = null,
    optional_seq_small_0_midfield: ?EnumParseTester.SeqSmall0 = null,
    optional_seq_small_0_hifield: ?EnumParseTester.SeqSmall0 = null,
    repeated_seq_small_0_lowfield: std.ArrayListUnmanaged(EnumParseTester.SeqSmall0) = .empty,
    repeated_seq_small_0_midfield: std.ArrayListUnmanaged(EnumParseTester.SeqSmall0) = .empty,
    repeated_seq_small_0_hifield: std.ArrayListUnmanaged(EnumParseTester.SeqSmall0) = .empty,
    packed_seq_small_0_lowfield: std.ArrayListUnmanaged(EnumParseTester.SeqSmall0) = .empty,
    packed_seq_small_0_midfield: std.ArrayListUnmanaged(EnumParseTester.SeqSmall0) = .empty,
    packed_seq_small_0_hifield: std.ArrayListUnmanaged(EnumParseTester.SeqSmall0) = .empty,
    optional_seq_small_1_lowfield: ?EnumParseTester.SeqSmall1 = null,
    optional_seq_small_1_midfield: ?EnumParseTester.SeqSmall1 = null,
    optional_seq_small_1_hifield: ?EnumParseTester.SeqSmall1 = null,
    repeated_seq_small_1_lowfield: std.ArrayListUnmanaged(EnumParseTester.SeqSmall1) = .empty,
    repeated_seq_small_1_midfield: std.ArrayListUnmanaged(EnumParseTester.SeqSmall1) = .empty,
    repeated_seq_small_1_hifield: std.ArrayListUnmanaged(EnumParseTester.SeqSmall1) = .empty,
    packed_seq_small_1_lowfield: std.ArrayListUnmanaged(EnumParseTester.SeqSmall1) = .empty,
    packed_seq_small_1_midfield: std.ArrayListUnmanaged(EnumParseTester.SeqSmall1) = .empty,
    packed_seq_small_1_hifield: std.ArrayListUnmanaged(EnumParseTester.SeqSmall1) = .empty,
    optional_seq_large_lowfield: ?EnumParseTester.SeqLarge = null,
    optional_seq_large_midfield: ?EnumParseTester.SeqLarge = null,
    optional_seq_large_hifield: ?EnumParseTester.SeqLarge = null,
    repeated_seq_large_lowfield: std.ArrayListUnmanaged(EnumParseTester.SeqLarge) = .empty,
    repeated_seq_large_midfield: std.ArrayListUnmanaged(EnumParseTester.SeqLarge) = .empty,
    repeated_seq_large_hifield: std.ArrayListUnmanaged(EnumParseTester.SeqLarge) = .empty,
    packed_seq_large_lowfield: std.ArrayListUnmanaged(EnumParseTester.SeqLarge) = .empty,
    packed_seq_large_midfield: std.ArrayListUnmanaged(EnumParseTester.SeqLarge) = .empty,
    packed_seq_large_hifield: std.ArrayListUnmanaged(EnumParseTester.SeqLarge) = .empty,
    optional_arbitrary_lowfield: ?EnumParseTester.Arbitrary = null,
    optional_arbitrary_midfield: ?EnumParseTester.Arbitrary = null,
    optional_arbitrary_hifield: ?EnumParseTester.Arbitrary = null,
    repeated_arbitrary_lowfield: std.ArrayListUnmanaged(EnumParseTester.Arbitrary) = .empty,
    repeated_arbitrary_midfield: std.ArrayListUnmanaged(EnumParseTester.Arbitrary) = .empty,
    repeated_arbitrary_hifield: std.ArrayListUnmanaged(EnumParseTester.Arbitrary) = .empty,
    packed_arbitrary_lowfield: std.ArrayListUnmanaged(EnumParseTester.Arbitrary) = .empty,
    packed_arbitrary_midfield: std.ArrayListUnmanaged(EnumParseTester.Arbitrary) = .empty,
    packed_arbitrary_hifield: std.ArrayListUnmanaged(EnumParseTester.Arbitrary) = .empty,
    other_field: ?i32 = null,

    pub const _desc_table = .{
        .optional_seq_small_0_lowfield = fd(1, .@"enum"),
        .optional_seq_small_0_midfield = fd(1001, .@"enum"),
        .optional_seq_small_0_hifield = fd(1000001, .@"enum"),
        .repeated_seq_small_0_lowfield = fd(2, .{ .repeated = .@"enum" }),
        .repeated_seq_small_0_midfield = fd(1002, .{ .repeated = .@"enum" }),
        .repeated_seq_small_0_hifield = fd(1000002, .{ .repeated = .@"enum" }),
        .packed_seq_small_0_lowfield = fd(3, .{ .packed_repeated = .@"enum" }),
        .packed_seq_small_0_midfield = fd(1003, .{ .packed_repeated = .@"enum" }),
        .packed_seq_small_0_hifield = fd(1000003, .{ .packed_repeated = .@"enum" }),
        .optional_seq_small_1_lowfield = fd(4, .@"enum"),
        .optional_seq_small_1_midfield = fd(1004, .@"enum"),
        .optional_seq_small_1_hifield = fd(1000004, .@"enum"),
        .repeated_seq_small_1_lowfield = fd(5, .{ .repeated = .@"enum" }),
        .repeated_seq_small_1_midfield = fd(1005, .{ .repeated = .@"enum" }),
        .repeated_seq_small_1_hifield = fd(1000005, .{ .repeated = .@"enum" }),
        .packed_seq_small_1_lowfield = fd(6, .{ .packed_repeated = .@"enum" }),
        .packed_seq_small_1_midfield = fd(1006, .{ .packed_repeated = .@"enum" }),
        .packed_seq_small_1_hifield = fd(1000006, .{ .packed_repeated = .@"enum" }),
        .optional_seq_large_lowfield = fd(7, .@"enum"),
        .optional_seq_large_midfield = fd(1007, .@"enum"),
        .optional_seq_large_hifield = fd(1000007, .@"enum"),
        .repeated_seq_large_lowfield = fd(8, .{ .repeated = .@"enum" }),
        .repeated_seq_large_midfield = fd(1008, .{ .repeated = .@"enum" }),
        .repeated_seq_large_hifield = fd(1000008, .{ .repeated = .@"enum" }),
        .packed_seq_large_lowfield = fd(9, .{ .packed_repeated = .@"enum" }),
        .packed_seq_large_midfield = fd(1009, .{ .packed_repeated = .@"enum" }),
        .packed_seq_large_hifield = fd(1000009, .{ .packed_repeated = .@"enum" }),
        .optional_arbitrary_lowfield = fd(10, .@"enum"),
        .optional_arbitrary_midfield = fd(1010, .@"enum"),
        .optional_arbitrary_hifield = fd(1000010, .@"enum"),
        .repeated_arbitrary_lowfield = fd(11, .{ .repeated = .@"enum" }),
        .repeated_arbitrary_midfield = fd(1011, .{ .repeated = .@"enum" }),
        .repeated_arbitrary_hifield = fd(1000011, .{ .repeated = .@"enum" }),
        .packed_arbitrary_lowfield = fd(12, .{ .packed_repeated = .@"enum" }),
        .packed_arbitrary_midfield = fd(1012, .{ .packed_repeated = .@"enum" }),
        .packed_arbitrary_hifield = fd(1000012, .{ .packed_repeated = .@"enum" }),
        .other_field = fd(99, .{ .scalar = .int32 }),
    };

    pub const SeqSmall0 = enum(i32) {
        SEQ_SMALL_0_DEFAULT = 0,
        SEQ_SMALL_0_1 = 1,
        SEQ_SMALL_0_2 = 2,
        _,
    };

    pub const SeqSmall1 = enum(i32) {
        SEQ_SMALL_1_DEFAULT = 1,
        SEQ_SMALL_1_2 = 2,
        SEQ_SMALL_1_3 = 3,
        _,
    };

    pub const SeqLarge = enum(i32) {
        SEQ_LARGE_DEFAULT = -1,
        SEQ_LARGE_0 = 0,
        SEQ_LARGE_1 = 1,
        SEQ_LARGE_2 = 2,
        SEQ_LARGE_3 = 3,
        SEQ_LARGE_4 = 4,
        SEQ_LARGE_5 = 5,
        SEQ_LARGE_6 = 6,
        SEQ_LARGE_7 = 7,
        SEQ_LARGE_8 = 8,
        SEQ_LARGE_9 = 9,
        SEQ_LARGE_10 = 10,
        SEQ_LARGE_11 = 11,
        SEQ_LARGE_12 = 12,
        SEQ_LARGE_13 = 13,
        SEQ_LARGE_14 = 14,
        SEQ_LARGE_15 = 15,
        SEQ_LARGE_16 = 16,
        SEQ_LARGE_17 = 17,
        SEQ_LARGE_18 = 18,
        SEQ_LARGE_19 = 19,
        SEQ_LARGE_20 = 20,
        SEQ_LARGE_21 = 21,
        SEQ_LARGE_22 = 22,
        SEQ_LARGE_23 = 23,
        SEQ_LARGE_24 = 24,
        SEQ_LARGE_25 = 25,
        SEQ_LARGE_26 = 26,
        SEQ_LARGE_27 = 27,
        SEQ_LARGE_28 = 28,
        SEQ_LARGE_29 = 29,
        SEQ_LARGE_30 = 30,
        SEQ_LARGE_31 = 31,
        SEQ_LARGE_32 = 32,
        SEQ_LARGE_33 = 33,
        _,
    };

    pub const Arbitrary = enum(i32) {
        ARBITRARY_DEFAULT = -123123,
        ARBITRARY_1 = -123,
        ARBITRARY_2 = 213,
        ARBITRARY_3 = 213213,
        ARBITRARY_MIN = -2147483648,
        ARBITRARY_MAX = 2147483647,
        _,
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

pub fn TestServiceImplementations(comptime ServerContext: type) type {
    return struct {
        Foo: *const fn (context: *ServerContext, request: FooRequest) anyerror!FooResponse,
        Bar: *const fn (context: *ServerContext, request: BarRequest) anyerror!BarResponse,
    };
}

pub fn TestService(comptime ServerContext: type) type {
    return struct {
        context: *ServerContext,
        implementations: TestServiceImplementations(ServerContext),

        pub fn Foo(self: @This(), request: FooRequest) anyerror!FooResponse {
            return self.implementations.Foo(self.context, request);
        }

        pub fn Bar(self: @This(), request: BarRequest) anyerror!BarResponse {
            return self.implementations.Bar(self.context, request);
        }
    };
}
